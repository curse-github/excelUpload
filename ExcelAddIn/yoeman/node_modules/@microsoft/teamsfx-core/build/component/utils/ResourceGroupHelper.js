"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resourceGroupHelper = exports.ResourceGroupHelper = exports.DefaultResourceGroupLocation = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const arm_resources_1 = require("@azure/arm-resources");
const arm_subscriptions_1 = require("@azure/arm-subscriptions");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../../common/constants");
const globalVars_1 = require("../../core/globalVars");
const question_1 = require("../../core/question");
const azure_1 = require("../../error/azure");
const constants_2 = require("../constants");
const MsResources = "Microsoft.Resources";
const ResourceGroups = "resourceGroups";
exports.DefaultResourceGroupLocation = "East US";
// TODO: use the emoji plus sign like Azure Functions extension
const newResourceGroupOption = "+ New resource group";
class ResourceGroupHelper {
    async createNewResourceGroup(resourceGroupName, azureAccountProvider, subscriptionId, location) {
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken)
            return teamsfx_api_1.err(new azure_1.InvalidAzureCredentialError());
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
        const maybeExist = await this.checkResourceGroupExistence(resourceGroupName, rmClient);
        if (maybeExist.isErr()) {
            return teamsfx_api_1.err(maybeExist.error);
        }
        if (maybeExist.value) {
            return teamsfx_api_1.err(new azure_1.ResourceGroupConflictError(resourceGroupName, subscriptionId));
        }
        try {
            const response = await rmClient.resourceGroups.createOrUpdate(resourceGroupName, {
                location: location,
                tags: { "created-by": "teamsfx" },
            });
            if (response.name === undefined) {
                return teamsfx_api_1.err(new azure_1.CreateResourceGroupError(resourceGroupName, subscriptionId, `illegal response: ${JSON.stringify(response)}`));
            }
            return teamsfx_api_1.ok(response.name);
        }
        catch (e) {
            return teamsfx_api_1.err(new azure_1.CreateResourceGroupError(resourceGroupName, subscriptionId, e.message || JSON.stringify(e)));
        }
    }
    async checkResourceGroupExistence(resourceGroupName, rmClient) {
        try {
            const checkRes = await rmClient.resourceGroups.checkExistence(resourceGroupName);
            return teamsfx_api_1.ok(!!checkRes.body);
        }
        catch (e) {
            return teamsfx_api_1.err(new azure_1.CheckResourceGroupExistenceError(resourceGroupName, rmClient.subscriptionId, JSON.stringify(e)));
        }
    }
    async getResourceGroupInfo(resourceGroupName, rmClient) {
        try {
            const getRes = await rmClient.resourceGroups.get(resourceGroupName);
            if (getRes.name) {
                return teamsfx_api_1.ok({
                    createNewResourceGroup: false,
                    name: getRes.name,
                    location: getRes.location,
                });
            }
            else
                return teamsfx_api_1.ok(undefined);
        }
        catch (e) {
            return teamsfx_api_1.err(new azure_1.GetResourceGroupError(resourceGroupName, rmClient.subscriptionId, e.message || JSON.stringify(e)));
        }
    }
    async listResourceGroups(rmClient) {
        try {
            const results = [];
            const res = rmClient.resourceGroups.list();
            let result = await res.next();
            if (result.value.name)
                results.push([result.value.name, result.value.location]);
            while (!result.done) {
                if (result.value.name)
                    results.push([result.value.name, result.value.location]);
                result = await res.next();
            }
            return teamsfx_api_1.ok(results);
        }
        catch (e) {
            return teamsfx_api_1.err(new azure_1.ListResourceGroupsError(rmClient.subscriptionId, e.message || JSON.stringify(e)));
        }
    }
    async getLocations(azureAccountProvider, rmClient) {
        var _a;
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken)
            return teamsfx_api_1.err(new azure_1.InvalidAzureCredentialError());
        const subscriptionClient = new arm_subscriptions_1.SubscriptionClient(azureToken);
        const askSubRes = await azureAccountProvider.getSelectedSubscription(true);
        try {
            const res = subscriptionClient.subscriptions.listLocations(askSubRes.subscriptionId);
            const locations = [];
            let result = await res.next();
            if (result.value.displayName)
                locations.push(result.value.displayName);
            while (!result.done) {
                if (result.value.displayName)
                    locations.push(result.value.displayName);
                result = await res.next();
            }
            const providerData = await rmClient.providers.get(MsResources);
            const resourceTypeData = (_a = providerData.resourceTypes) === null || _a === void 0 ? void 0 : _a.find((rt) => { var _a; return ((_a = rt.resourceType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ResourceGroups.toLowerCase(); });
            const resourceLocations = resourceTypeData === null || resourceTypeData === void 0 ? void 0 : resourceTypeData.locations;
            const rgLocations = resourceLocations === null || resourceLocations === void 0 ? void 0 : resourceLocations.filter((item) => locations.includes(item));
            if (!rgLocations || rgLocations.length == 0) {
                return teamsfx_api_1.err(new azure_1.ListResourceGroupLocationsError(rmClient.subscriptionId, "No available locations found!"));
            }
            return teamsfx_api_1.ok(rgLocations);
        }
        catch (e) {
            return teamsfx_api_1.err(new azure_1.ListResourceGroupLocationsError(rmClient.subscriptionId, e.message || JSON.stringify(e)));
        }
    }
    async getQuestionsForResourceGroup(defaultResourceGroupName, existingResourceGroupNameLocations, availableLocations, rmClient) {
        const selectResourceGroup = question_1.QuestionSelectResourceGroup();
        const staticOptions = [
            { id: newResourceGroupOption, label: newResourceGroupOption },
        ];
        selectResourceGroup.staticOptions = staticOptions.concat(existingResourceGroupNameLocations.map((item) => {
            return {
                id: item[0],
                label: item[0],
                description: item[1],
            };
        }));
        const node = new teamsfx_api_1.QTreeNode(selectResourceGroup);
        const existingResourceGroupNames = existingResourceGroupNameLocations.map((item) => item[0]);
        const inputNewResourceGroupName = question_1.newResourceGroupNameQuestion(existingResourceGroupNames);
        inputNewResourceGroupName.default = defaultResourceGroupName;
        const newResourceGroupNameNode = new teamsfx_api_1.QTreeNode(inputNewResourceGroupName);
        newResourceGroupNameNode.condition = { equals: newResourceGroupOption };
        node.addChild(newResourceGroupNameNode);
        const selectLocation = question_1.QuestionNewResourceGroupLocation();
        // TODO: maybe lazily load locations
        selectLocation.staticOptions = availableLocations;
        selectLocation.default = "East US";
        const newResourceGroupLocationNode = new teamsfx_api_1.QTreeNode(selectLocation);
        newResourceGroupNameNode.addChild(newResourceGroupLocationNode);
        return node.trim();
    }
    /**
     * Ask user to create a new resource group or use an existing resource group
     */
    async askResourceGroupInfo(ctx, inputs, azureAccountProvider, rmClient, defaultResourceGroupName) {
        return this.askResourceGroupInfoV3(azureAccountProvider, rmClient, defaultResourceGroupName);
    }
    /**
     * Ask user to create a new resource group or use an existing resource group  V3
     */
    async askResourceGroupInfoV3(azureAccountProvider, rmClient, defaultResourceGroupName) {
        var _a;
        const listRgRes = await this.listResourceGroups(rmClient);
        if (listRgRes.isErr())
            return teamsfx_api_1.err(listRgRes.error);
        const getLocationsRes = await this.getLocations(azureAccountProvider, rmClient);
        if (getLocationsRes.isErr()) {
            return teamsfx_api_1.err(getLocationsRes.error);
        }
        const node = await this.getQuestionsForResourceGroup(defaultResourceGroupName, listRgRes.value, getLocationsRes.value, rmClient);
        const inputs = {
            platform: teamsfx_api_1.Platform.VSCode,
        };
        if (node) {
            const res = await teamsfx_api_1.traverse(node, inputs, globalVars_1.TOOLS.ui);
            if (res.isErr()) {
                (_a = globalVars_1.TOOLS.logProvider) === null || _a === void 0 ? void 0 : _a.debug(`[${constants_1.PluginDisplayName.Solution}] failed to run question model for target resource group.`);
                return teamsfx_api_1.err(res.error);
            }
        }
        const targetResourceGroupName = inputs.targetResourceGroupName;
        if (!targetResourceGroupName || typeof targetResourceGroupName !== "string") {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "InvalidInputError", "Invalid targetResourceGroupName"));
        }
        const resourceGroupName = inputs.targetResourceGroupName;
        if (resourceGroupName === newResourceGroupOption) {
            return teamsfx_api_1.ok({
                name: inputs[question_1.CoreQuestionNames.NewResourceGroupName],
                location: inputs[question_1.CoreQuestionNames.NewResourceGroupLocation],
                createNewResourceGroup: true,
            });
        }
        else {
            const target = listRgRes.value.find((item) => item[0] == targetResourceGroupName);
            const location = target[1]; // location must exist because the user can only select from this list.
            return teamsfx_api_1.ok({
                createNewResourceGroup: false,
                name: targetResourceGroupName,
                location: location,
            });
        }
    }
}
exports.ResourceGroupHelper = ResourceGroupHelper;
exports.resourceGroupHelper = new ResourceGroupHelper();
//# sourceMappingURL=ResourceGroupHelper.js.map