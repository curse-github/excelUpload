"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coordinator = exports.Coordinator = exports.InitTemplateName = exports.Feature2TemplateName = exports.TemplateNames = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const uuid = tslib_1.__importStar(require("uuid"));
const xml2js = tslib_1.__importStar(require("xml2js"));
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const globalState_1 = require("../../common/globalState");
const localizeUtils_1 = require("../../common/localizeUtils");
const telemetry_1 = require("../../common/telemetry");
const tools_1 = require("../../common/tools");
const versionMetadata_1 = require("../../common/versionMetadata");
const downloadSample_1 = require("../../core/downloadSample");
const error_1 = require("../../core/error");
const globalVars_1 = require("../../core/globalVars");
const question_1 = require("../../core/question");
const azure_1 = require("../../error/azure");
const common_1 = require("../../error/common");
const yml_1 = require("../../error/yml");
const utils_1 = require("../code/utils");
const constants_1 = require("../constants");
const core_1 = require("../core");
const deployUtils_1 = require("../deployUtils");
const developerPortalScaffoldUtils_1 = require("../developerPortalScaffoldUtils");
const constants_2 = require("../feature/bot/constants");
const question_2 = require("../feature/bot/question");
const generator_1 = require("../generator/generator");
const generator_2 = require("../generator/officeAddin/generator");
const spfxGenerator_1 = require("../generator/spfxGenerator");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const provisionUtils_1 = require("../provisionUtils");
const question_3 = require("../question");
const appStudio_1 = require("../resource/appManifest/appStudio");
const constants_3 = require("../resource/appManifest/constants");
const envUtil_1 = require("../utils/envUtil");
const metadataUtil_1 = require("../utils/metadataUtil");
const pathUtils_1 = require("../utils/pathUtils");
const ResourceGroupHelper_1 = require("../utils/ResourceGroupHelper");
const settingsUtil_1 = require("../utils/settingsUtil");
const summary_1 = require("./summary");
var TemplateNames;
(function (TemplateNames) {
    TemplateNames["Tab"] = "non-sso-tab";
    TemplateNames["SsoTab"] = "sso-tab";
    TemplateNames["M365Tab"] = "m365-tab";
    TemplateNames["DashboardTab"] = "dashboard-tab";
    TemplateNames["NotificationRestify"] = "notification-restify";
    TemplateNames["NotificationWebApi"] = "notification-webapi";
    TemplateNames["NotificationHttpTrigger"] = "notification-http-trigger";
    TemplateNames["NotificationTimerTrigger"] = "notification-timer-trigger";
    TemplateNames["NotificationHttpTimerTrigger"] = "notification-http-timer-trigger";
    TemplateNames["CommandAndResponse"] = "command-and-response";
    TemplateNames["Workflow"] = "workflow";
    TemplateNames["DefaultBot"] = "default-bot";
    TemplateNames["MessageExtension"] = "message-extension";
    TemplateNames["M365MessageExtension"] = "m365-message-extension";
    TemplateNames["TabAndDefaultBot"] = "non-sso-tab-default-bot";
    TemplateNames["BotAndMessageExtension"] = "default-bot-message-extension";
})(TemplateNames = exports.TemplateNames || (exports.TemplateNames = {}));
exports.Feature2TemplateName = {
    [`${constants_1.NotificationOptionItem().id}:${question_2.AppServiceOptionItem().id}`]: TemplateNames.NotificationRestify,
    [`${constants_1.NotificationOptionItem().id}:${question_2.AppServiceOptionItemForVS().id}`]: TemplateNames.NotificationWebApi,
    [`${constants_1.NotificationOptionItem().id}:${question_2.FunctionsHttpTriggerOptionItem().id}`]: TemplateNames.NotificationHttpTrigger,
    [`${constants_1.NotificationOptionItem().id}:${question_2.FunctionsTimerTriggerOptionItem().id}`]: TemplateNames.NotificationTimerTrigger,
    [`${constants_1.NotificationOptionItem().id}:${question_2.FunctionsHttpAndTimerTriggerOptionItem().id}`]: TemplateNames.NotificationHttpTimerTrigger,
    [`${constants_1.CommandAndResponseOptionItem().id}:undefined`]: TemplateNames.CommandAndResponse,
    [`${constants_1.WorkflowOptionItem().id}:undefined`]: TemplateNames.Workflow,
    [`${constants_1.BotOptionItem().id}:undefined`]: TemplateNames.DefaultBot,
    [`${constants_1.MessageExtensionItem().id}:undefined`]: TemplateNames.MessageExtension,
    [`${constants_1.M365SearchAppOptionItem().id}:undefined`]: TemplateNames.M365MessageExtension,
    [`${constants_1.TabOptionItem().id}:undefined`]: TemplateNames.SsoTab,
    [`${constants_1.TabNonSsoItem().id}:undefined`]: TemplateNames.Tab,
    [`${constants_1.M365SsoLaunchPageOptionItem().id}:undefined`]: TemplateNames.M365Tab,
    [`${constants_1.DashboardOptionItem().id}:undefined`]: TemplateNames.DashboardTab,
    [`${constants_1.TabNonSsoAndDefaultBotItem().id}:undefined`]: TemplateNames.TabAndDefaultBot,
    [`${constants_1.DefaultBotAndMessageExtensionItem().id}:undefined`]: TemplateNames.BotAndMessageExtension,
};
exports.InitTemplateName = {
    ["debug:vsc:tab:true"]: "init-debug-vsc-spfx-tab",
    ["debug:vsc:tab:false"]: "init-debug-vsc-tab",
    ["debug:vs:tab:undefined"]: "init-debug-vs-tab",
    ["debug:vsc:bot:undefined"]: "init-debug-vsc-bot",
    ["debug:vs:bot:undefined"]: "init-debug-vs-bot",
    ["infra:vsc:tab:true"]: "init-infra-vsc-spfx-tab",
    ["infra:vsc:tab:false"]: "init-infra-vsc-tab",
    ["infra:vs:tab:undefined"]: "init-infra-vs-tab",
    ["infra:vsc:bot:undefined"]: "init-infra-vsc-bot",
    ["infra:vs:bot:undefined"]: "init-infra-vs-bot",
};
const M365Actions = [
    "botAadApp/create",
    "teamsApp/create",
    "teamsApp/update",
    "aadApp/create",
    "aadApp/update",
    "botFramework/create",
    "teamsApp/extendToM365",
];
const AzureActions = ["arm/deploy"];
const AzureDeployActions = [
    "azureAppService/zipDeploy",
    "azureFunctions/zipDeploy",
    "azureStorage/deploy",
];
const needTenantCheckActions = ["botAadApp/create", "aadApp/create", "botFramework/create"];
class Coordinator {
    async create(context, inputs, actionContext) {
        const folder = inputs["folder"];
        if (!folder) {
            return teamsfx_api_1.err(new common_1.MissingRequiredInputError("folder"));
        }
        const scratch = inputs[question_1.CoreQuestionNames.CreateFromScratch];
        let projectPath = "";
        const automaticNpmInstall = "automaticNpmInstall";
        if (scratch === question_1.ScratchOptionNo().id) {
            // create from sample
            const sampleId = inputs[question_1.CoreQuestionNames.Samples];
            if (!sampleId) {
                throw new common_1.MissingRequiredInputError(question_1.CoreQuestionNames.Samples);
            }
            projectPath = path.join(folder, sampleId);
            let suffix = 1;
            while ((await fs_extra_1.default.pathExists(projectPath)) && (await fs_extra_1.default.readdir(projectPath)).length > 0) {
                projectPath = path.join(folder, `${sampleId}_${suffix++}`);
            }
            inputs.projectPath = projectPath;
            await fs_extra_1.default.ensureDir(projectPath);
            const res = await generator_1.Generator.generateSample(context, projectPath, sampleId);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            await downloadSample_1.downloadSampleHook(sampleId, projectPath);
        }
        else if (!scratch || scratch === question_1.ScratchOptionYes().id) {
            // create from new
            const appName = inputs[question_1.CoreQuestionNames.AppName];
            if (undefined === appName)
                return teamsfx_api_1.err(new common_1.MissingRequiredInputError(question_1.CoreQuestionNames.AppName));
            const validateResult = jsonschema.validate(appName, {
                pattern: question_1.ProjectNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(new common_1.InputValidationError(question_1.CoreQuestionNames.AppName, validateResult.errors[0].message));
            }
            projectPath = path.join(folder, appName);
            inputs.projectPath = projectPath;
            await fs_extra_1.default.ensureDir(projectPath);
            // set isVS global var when creating project
            const language = inputs[question_1.CoreQuestionNames.ProgrammingLanguage];
            globalVars_1.globalVars.isVS = language === "csharp";
            const feature = inputs.capabilities;
            delete inputs.folder;
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Capabilities]: feature,
                [telemetry_1.TelemetryProperty.IsFromTdp]: (!!inputs.teamsAppFromTdp).toString(),
            });
            if (feature === constants_1.TabSPFxNewUIItem().id) {
                const res = await spfxGenerator_1.SPFxGenerator.generate(context, inputs, projectPath);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
            }
            else if (inputs[question_1.CoreQuestionNames.ProjectType] === constants_1.NewProjectTypeOutlookAddinOptionItem().id) {
                const res = await generator_2.OfficeAddinGenerator.generate(context, inputs, projectPath);
                if (res.isErr()) {
                    return teamsfx_api_1.err(res.error);
                }
            }
            else {
                if (feature === constants_1.M365SsoLaunchPageOptionItem().id ||
                    feature === constants_1.M365SearchAppOptionItem().id) {
                    context.projectSetting.isM365 = true;
                    inputs.isM365 = true;
                }
                const trigger = inputs[constants_2.QuestionNames.BOT_HOST_TYPE_TRIGGER];
                const templateName = exports.Feature2TemplateName[`${feature}:${trigger}`];
                if (templateName) {
                    const langKey = utils_1.convertToLangKey(language);
                    const safeProjectNameFromVS = language === "csharp" ? inputs[question_1.CoreQuestionNames.SafeProjectName] : undefined;
                    context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS);
                    const res = await generator_1.Generator.generateTemplate(context, projectPath, templateName, langKey);
                    if (res.isErr())
                        return teamsfx_api_1.err(res.error);
                }
            }
        }
        // generate unique projectId in teamsapp.yaml (optional)
        const ymlPath = path.join(projectPath, versionMetadata_1.MetadataV3.configFile);
        if (fs_extra_1.default.pathExistsSync(ymlPath)) {
            const ensureRes = await this.ensureTrackingId(projectPath, inputs.projectId);
            if (ensureRes.isErr())
                return teamsfx_api_1.err(ensureRes.error);
            inputs.projectId = ensureRes.value;
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(automaticNpmInstall, true);
        }
        context.projectPath = projectPath;
        if (inputs.teamsAppFromTdp) {
            const res = await developerPortalScaffoldUtils_1.developerPortalScaffoldUtils.updateFilesForTdp(context, inputs.teamsAppFromTdp, inputs);
            if (res.isErr()) {
                return teamsfx_api_1.err(res.error);
            }
        }
        return teamsfx_api_1.ok(projectPath);
    }
    async initInfra(context, inputs, actionContext) {
        if (inputs.proceed === question_3.InitOptionNo().id)
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(error_1.InvalidInputError("projectPath is undefined"));
        }
        const editor = inputs.editor;
        const capability = inputs.capability;
        const spfx = inputs.spfx;
        if (!editor)
            return teamsfx_api_1.err(error_1.InvalidInputError("editor is undefined"));
        if (!capability)
            return teamsfx_api_1.err(error_1.InvalidInputError("capability is undefined"));
        const templateName = exports.InitTemplateName[`infra:${editor}:${capability}:${spfx}`];
        if (!templateName) {
            return teamsfx_api_1.err(error_1.InvalidInputError("templateName is undefined"));
        }
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        const originalTrackingId = settingsRes.isOk() ? settingsRes.value.trackingId : undefined;
        const res = await generator_1.Generator.generateTemplate(context, projectPath, templateName, undefined);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const ensureRes = await this.ensureTrackingId(projectPath, originalTrackingId);
        if (ensureRes.isErr())
            return teamsfx_api_1.err(ensureRes.error);
        if (actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps)
            actionContext.telemetryProps["project-id"] = ensureRes.value;
        if (editor === question_3.InitEditorVS().id) {
            const ensure = await this.ensureTeamsFxInCsproj(projectPath);
            if (ensure.isErr())
                return teamsfx_api_1.err(ensure.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async ensureTeamsFxInCsproj(projectPath) {
        const list = await fs_extra_1.default.readdir(projectPath);
        const csprojFiles = list.filter((fileName) => fileName.endsWith(".csproj"));
        if (csprojFiles.length === 0)
            return teamsfx_api_1.ok(undefined);
        const filePath = csprojFiles[0];
        const xmlStringOld = (await fs_extra_1.default.readFile(filePath, { encoding: "utf8" })).toString();
        const jsonObj = await xml2js.parseStringPromise(xmlStringOld);
        let ItemGroup = jsonObj.Project.ItemGroup;
        if (!ItemGroup) {
            ItemGroup = [];
            jsonObj.Project.ItemGroup = ItemGroup;
        }
        const existItems = ItemGroup.filter((item) => {
            var _a;
            if (item.ProjectCapability && item.ProjectCapability[0])
                if (((_a = item.ProjectCapability[0]["$"]) === null || _a === void 0 ? void 0 : _a.Include) === "TeamsFx")
                    return true;
            return false;
        });
        if (existItems.length === 0) {
            const toAdd = {
                ProjectCapability: [
                    {
                        $: {
                            Include: "TeamsFx",
                        },
                    },
                ],
            };
            ItemGroup.push(toAdd);
            const builder = new xml2js.Builder();
            const xmlStringNew = builder.buildObject(jsonObj);
            await fs_extra_1.default.writeFile(filePath, xmlStringNew, { encoding: "utf8" });
        }
        return teamsfx_api_1.ok(undefined);
    }
    async initDebug(context, inputs, actionContext) {
        if (inputs.proceed === question_3.InitOptionNo().id)
            return teamsfx_api_1.err(teamsfx_api_1.UserCancelError);
        const projectPath = inputs.projectPath;
        if (!projectPath) {
            return teamsfx_api_1.err(error_1.InvalidInputError("projectPath is undefined"));
        }
        const editor = inputs.editor;
        const capability = inputs.capability;
        const spfx = inputs.spfx;
        if (!editor)
            return teamsfx_api_1.err(error_1.InvalidInputError("editor is undefined"));
        if (!capability)
            return teamsfx_api_1.err(error_1.InvalidInputError("capability is undefined"));
        const templateName = exports.InitTemplateName[`debug:${editor}:${capability}:${spfx}`];
        if (!templateName) {
            return teamsfx_api_1.err(error_1.InvalidInputError("templateName is undefined"));
        }
        if (editor === question_3.InitEditorVSCode().id) {
            const exists = await fs_extra_1.default.pathExists(path.join(projectPath, ".vscode"));
            context.templateVariables = { dotVscodeFolderName: exists ? ".vscode-teamsfx" : ".vscode" };
        }
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        const originalTrackingId = settingsRes.isOk() ? settingsRes.value.trackingId : undefined;
        const res = await generator_1.Generator.generateTemplate(context, projectPath, templateName, undefined);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const ensureRes = await this.ensureTrackingId(projectPath, originalTrackingId);
        if (ensureRes.isErr())
            return teamsfx_api_1.err(ensureRes.error);
        if (actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps)
            actionContext.telemetryProps["project-id"] = ensureRes.value;
        if (editor === question_3.InitEditorVS().id) {
            const ensure = await this.ensureTeamsFxInCsproj(projectPath);
            if (ensure.isErr())
                return teamsfx_api_1.err(ensure.error);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async ensureTrackingId(projectPath, trackingId = undefined) {
        // generate unique trackingId in settings.json
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
        if (settingsRes.isErr())
            return teamsfx_api_1.err(settingsRes.error);
        const settings = settingsRes.value;
        if (settings.trackingId && !trackingId)
            return teamsfx_api_1.ok(settings.trackingId); // do nothing
        settings.trackingId = trackingId || uuid.v4();
        await settingsUtil_1.settingsUtil.writeSettings(projectPath, settings);
        return teamsfx_api_1.ok(settings.trackingId);
    }
    /**
     * add feature
     */
    async addFeature(context, inputs, actionContext) {
        const features = inputs[constants_1.AzureSolutionQuestionNames.Features];
        let component;
        if (constants_1.BotFeatureIds().includes(features)) {
            component = typedi_1.Container.get(constants_1.ComponentNames.TeamsBot);
        }
        else if (constants_1.TabFeatureIds().includes(features)) {
            component = typedi_1.Container.get(constants_1.ComponentNames.TeamsTab);
        }
        else if (features === constants_1.AzureResourceSQLNewUI.id) {
            component = typedi_1.Container.get("sql");
        }
        else if (features === constants_1.AzureResourceFunctionNewUI.id) {
            component = typedi_1.Container.get(constants_1.ComponentNames.TeamsApi);
        }
        else if (features === constants_1.AzureResourceApim.id) {
            component = typedi_1.Container.get(constants_1.ComponentNames.APIMFeature);
        }
        else if (features === constants_1.AzureResourceKeyVaultNewUI.id) {
            component = typedi_1.Container.get("key-vault-feature");
        }
        else if (features === constants_1.CicdOptionItem.id) {
            component = typedi_1.Container.get("cicd");
        }
        else if (features === constants_1.ApiConnectionOptionItem.id) {
            component = typedi_1.Container.get("api-connector");
        }
        else if (features === constants_1.SingleSignOnOptionItem.id) {
            component = typedi_1.Container.get("sso");
        }
        else if (features === constants_1.TabSPFxNewUIItem().id) {
            component = typedi_1.Container.get(constants_1.ComponentNames.SPFxTab);
        }
        if (component) {
            const res = await component.add(context, inputs);
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Feature]: features,
            });
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            return teamsfx_api_1.ok(res.value);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async preProvisionForVS(ctx, inputs) {
        const res = {
            needAzureLogin: false,
            needM365Login: false,
        };
        // 1. parse yml to cycles
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [
            projectModel.registerApp,
            projectModel.provision,
            projectModel.configureApp,
        ].filter((c) => c !== undefined);
        // 2. check each cycle
        for (const cycle of cycles) {
            const unresolvedPlaceholders = cycle.resolvePlaceholders();
            let firstArmDriver;
            for (const driver of cycle.driverDefs) {
                if (AzureActions.includes(driver.uses)) {
                    res.needAzureLogin = true;
                    if (!firstArmDriver) {
                        firstArmDriver = driver;
                    }
                }
                if (M365Actions.includes(driver.uses)) {
                    res.needM365Login = true;
                }
            }
            if (firstArmDriver) {
                const withObj = firstArmDriver.with;
                res.resolvedAzureSubscriptionId = unresolvedPlaceholders.includes("AZURE_SUBSCRIPTION_ID")
                    ? undefined
                    : withObj["subscriptionId"];
                res.resolvedAzureResourceGroupName = unresolvedPlaceholders.includes("AZURE_RESOURCE_GROUP_NAME")
                    ? undefined
                    : withObj["resourceGroupName"];
            }
        }
        return teamsfx_api_1.ok(res);
    }
    async preCheckYmlAndEnvForVS(ctx, inputs) {
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [projectModel.provision].filter((c) => c !== undefined);
        let unresolvedPlaceholders = [];
        // 2. check each cycle
        for (const cycle of cycles) {
            unresolvedPlaceholders = unresolvedPlaceholders.concat(cycle.resolvePlaceholders());
        }
        if (unresolvedPlaceholders.length > 0) {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError(unresolvedPlaceholders.join(",")));
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async provision(ctx, inputs, actionContext) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const output = {};
        const folderName = path.parse(ctx.projectPath).name;
        // 1. parse yml
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const cycles = [
            // projectModel.registerApp,
            projectModel.provision,
            // projectModel.configureApp,
        ].filter((c) => c !== undefined);
        if (cycles.length === 0) {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError("provision"));
        }
        // 2. M365 sign in and tenant check if needed.
        let containsM365 = false;
        let containsAzure = false;
        const tenantSwitchCheckActions = [];
        cycles.forEach((cycle) => {
            var _a;
            (_a = cycle.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((def) => {
                if (M365Actions.includes(def.uses)) {
                    containsM365 = true;
                }
                else if (AzureActions.includes(def.uses)) {
                    containsAzure = true;
                }
                if (needTenantCheckActions.includes(def.uses)) {
                    tenantSwitchCheckActions.push(def.uses);
                }
            });
        });
        let m365tenantInfo = undefined;
        if (containsM365) {
            const tenantInfoInTokenRes = await provisionUtils_1.provisionUtils.getM365TenantId(ctx.m365TokenProvider);
            if (tenantInfoInTokenRes.isErr()) {
                return teamsfx_api_1.err(tenantInfoInTokenRes.error);
            }
            m365tenantInfo = tenantInfoInTokenRes.value;
            const checkM365TenatRes = await provisionUtils_1.provisionUtils.ensureM365TenantMatchesV3(tenantSwitchCheckActions, m365tenantInfo === null || m365tenantInfo === void 0 ? void 0 : m365tenantInfo.tenantIdInToken, inputs.env, constants_1.CoordinatorSource);
            if (checkM365TenatRes.isErr()) {
                return teamsfx_api_1.err(checkM365TenatRes.error);
            }
        }
        // We will update targetResourceGroupInfo if creating resource group is needed and create the resource group later after confirming with the user
        let targetResourceGroupInfo = {
            createNewResourceGroup: false,
            name: "",
            location: "",
        };
        let resolvedSubscriptionId;
        let resolvedResourceGroupName;
        let azureSubInfo = undefined;
        if (containsAzure) {
            //ensure RESOURCE_SUFFIX
            if (!process.env.RESOURCE_SUFFIX) {
                const suffix = process.env.RESOURCE_SUFFIX || uuid.v4().slice(0, 6);
                process.env.RESOURCE_SUFFIX = suffix;
                output.RESOURCE_SUFFIX = suffix;
            }
            // check whether placeholders are resolved
            let subscriptionUnresolved = false;
            let resourceGroupUnresolved = false;
            for (const cycle of cycles) {
                const unresolvedPlaceHolders = cycle.resolvePlaceholders();
                if (unresolvedPlaceHolders.includes("AZURE_SUBSCRIPTION_ID"))
                    subscriptionUnresolved = true;
                else {
                    (_a = cycle.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((driver) => {
                        const withObj = driver.with;
                        if (withObj && withObj.subscriptionId && resolvedSubscriptionId === undefined)
                            resolvedSubscriptionId = withObj.subscriptionId;
                    });
                }
                if (unresolvedPlaceHolders.includes("AZURE_RESOURCE_GROUP_NAME"))
                    resourceGroupUnresolved = true;
                else {
                    (_b = cycle.driverDefs) === null || _b === void 0 ? void 0 : _b.forEach((driver) => {
                        const withObj = driver.with;
                        if (withObj && withObj.resourceGroupName && resolvedResourceGroupName === undefined)
                            resolvedResourceGroupName = withObj.resourceGroupName;
                    });
                }
            }
            // ensure subscription, pop up UI to select if necessary
            if (subscriptionUnresolved) {
                if (inputs["targetSubscriptionId"]) {
                    process.env.AZURE_SUBSCRIPTION_ID = inputs["targetSubscriptionId"];
                    output.AZURE_SUBSCRIPTION_ID = inputs["targetSubscriptionId"];
                }
                else {
                    const ensureRes = await provisionUtils_1.provisionUtils.ensureSubscription(ctx.azureAccountProvider, undefined);
                    if (ensureRes.isErr())
                        return teamsfx_api_1.err(ensureRes.error);
                    const subInfo = ensureRes.value;
                    if (subInfo && subInfo.subscriptionId) {
                        process.env.AZURE_SUBSCRIPTION_ID = subInfo.subscriptionId;
                        output.AZURE_SUBSCRIPTION_ID = subInfo.subscriptionId;
                    }
                }
                resolvedSubscriptionId = process.env.AZURE_SUBSCRIPTION_ID;
            }
            // ensure resource group
            if (resourceGroupUnresolved) {
                const inputRG = inputs["targetResourceGroupName"];
                const inputLocation = inputs["targetResourceLocationName"];
                if (inputRG && inputLocation) {
                    // targetResourceGroupName is from VS inputs, which means create resource group if not exists
                    targetResourceGroupInfo.name = inputRG;
                    targetResourceGroupInfo.location = inputLocation;
                    targetResourceGroupInfo.createNewResourceGroup = true; // create resource group if not exists
                }
                else {
                    const defaultRg = `rg-${folderName}${process.env.RESOURCE_SUFFIX}-${inputs.env}`;
                    const ensureRes = await provisionUtils_1.provisionUtils.ensureResourceGroup(ctx.azureAccountProvider, resolvedSubscriptionId, undefined, defaultRg);
                    if (ensureRes.isErr())
                        return teamsfx_api_1.err(ensureRes.error);
                    targetResourceGroupInfo = ensureRes.value;
                    if (!targetResourceGroupInfo.createNewResourceGroup) {
                        process.env.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                        output.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                    }
                }
                resolvedResourceGroupName = targetResourceGroupInfo.name;
            }
            // consent user
            await ctx.azureAccountProvider.getIdentityCredentialAsync(true); // make sure login if ensureSubScription() is not called.
            try {
                await ctx.azureAccountProvider.setSubscription(resolvedSubscriptionId); //make sure sub is correctly set if ensureSubscription() is not called.
            }
            catch (e) {
                return teamsfx_api_1.err(teamsfx_api_1.assembleError(e));
            }
            azureSubInfo = await ctx.azureAccountProvider.getSelectedSubscription(false);
            if (!azureSubInfo) {
                return teamsfx_api_1.err(new azure_1.SelectSubscriptionError());
            }
            const consentRes = await provisionUtils_1.provisionUtils.askForProvisionConsentV3(ctx, m365tenantInfo, azureSubInfo, inputs.env);
            if (consentRes.isErr())
                return teamsfx_api_1.err(consentRes.error);
            // create resource group if necessary
            if (targetResourceGroupInfo.createNewResourceGroup) {
                const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(targetResourceGroupInfo.name, ctx.azureAccountProvider, resolvedSubscriptionId, targetResourceGroupInfo.location);
                if (createRgRes.isErr()) {
                    const error = createRgRes.error;
                    if (!(error instanceof azure_1.ResourceGroupConflictError)) {
                        return teamsfx_api_1.err(error);
                    }
                }
                process.env.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
                output.AZURE_RESOURCE_GROUP_NAME = targetResourceGroupInfo.name;
            }
        }
        // execute
        const summaryReporter = new summary_1.SummaryReporter(cycles, ctx.logProvider);
        const steps = cycles.reduce((acc, cur) => acc + cur.driverDefs.length, 0);
        let hasError = false;
        try {
            ctx.progressBar = (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.createProgressBar(localizeUtils_1.getLocalizedString("core.progress.provision"), steps);
            await ((_d = ctx.progressBar) === null || _d === void 0 ? void 0 : _d.start());
            const maybeDescription = summaryReporter.getLifecycleDescriptions();
            if (maybeDescription.isErr()) {
                hasError = true;
                return teamsfx_api_1.err(maybeDescription.error);
            }
            ctx.logProvider.info(`Executing app registration and provision ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
            for (const [index, cycle] of cycles.entries()) {
                const execRes = await cycle.execute(ctx);
                summaryReporter.updateLifecycleState(index, execRes);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                lodash_1.merge(output, result[0]);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return teamsfx_api_1.err(result[1]);
                }
            }
        }
        finally {
            const summary = summaryReporter.getLifecycleSummary(inputs.createdEnvFile);
            ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
            await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
        }
        // show provisioned resources
        const msg = localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.provision", steps, steps);
        if (azureSubInfo) {
            const url = tools_1.getResourceGroupInPortal(azureSubInfo.subscriptionId, azureSubInfo.tenantId, resolvedResourceGroupName);
            if (url && ctx.platform !== teamsfx_api_1.Platform.CLI) {
                const title = localizeUtils_1.getLocalizedString("core.provision.viewResources");
                (_f = ctx.ui) === null || _f === void 0 ? void 0 : _f.showMessage("info", msg, false, title).then((result) => {
                    var _a;
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === title) {
                        (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.openUrl(url);
                    }
                });
            }
            else {
                if (url && ctx.platform === teamsfx_api_1.Platform.CLI) {
                    (_g = ctx.ui) === null || _g === void 0 ? void 0 : _g.showMessage("info", [
                        {
                            content: `${msg} View the provisioned resources from `,
                            color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                        },
                        {
                            content: url,
                            color: teamsfx_api_1.Colors.BRIGHT_CYAN,
                        },
                    ], false);
                }
                else {
                    (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", msg, false);
                }
            }
        }
        else {
            if (ctx.platform === teamsfx_api_1.Platform.VS) {
                ctx.ui.showMessage("info", localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.prepareTeamsApp"), false);
            }
            else {
                ctx.ui.showMessage("info", msg, false);
            }
        }
        ctx.logProvider.info(msg);
        return teamsfx_api_1.ok(output);
    }
    convertExecuteResult(execRes, templatePath) {
        var _a;
        const output = {};
        let error = undefined;
        if (execRes.isErr()) {
            const execError = execRes.error;
            if (execError.kind === "Failure") {
                error = execError.error;
            }
            else {
                const partialOutput = execError.env;
                const newOutput = envUtil_1.envUtil.map2object(partialOutput);
                lodash_1.merge(output, newOutput);
                const reason = execError.reason;
                if (reason.kind === "DriverError") {
                    error = reason.error;
                }
                else if (reason.kind === "UnresolvedPlaceholders") {
                    const placeholders = ((_a = reason.unresolvedPlaceHolders) === null || _a === void 0 ? void 0 : _a.join(",")) || "";
                    error = new common_1.MissingEnvironmentVariablesError(lodash_1.camelCase(reason.failedDriver.uses), placeholders, templatePath);
                }
            }
        }
        else {
            const newOutput = envUtil_1.envUtil.map2object(execRes.value);
            lodash_1.merge(output, newOutput);
        }
        return [output, error];
    }
    async deploy(ctx, inputs, actionContext) {
        var _a, _b, _c, _d, _e;
        const output = {};
        const templatePath = inputs["workflowFilePath"] || pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        if (projectModel.deploy) {
            //check whether deploy to azure
            let containsAzure = false;
            (_a = projectModel.deploy.driverDefs) === null || _a === void 0 ? void 0 : _a.forEach((def) => {
                if (AzureDeployActions.includes(def.uses)) {
                    containsAzure = true;
                }
            });
            //consent
            if (containsAzure) {
                const consent = await deployUtils_1.deployUtils.askForDeployConsentV3(ctx);
                if (consent.isErr()) {
                    return teamsfx_api_1.err(consent.error);
                }
            }
            const summaryReporter = new summary_1.SummaryReporter([projectModel.deploy], ctx.logProvider);
            let hasError = false;
            try {
                const steps = projectModel.deploy.driverDefs.length;
                ctx.progressBar = (_b = ctx.ui) === null || _b === void 0 ? void 0 : _b.createProgressBar(localizeUtils_1.getLocalizedString("core.progress.deploy"), steps);
                await ((_c = ctx.progressBar) === null || _c === void 0 ? void 0 : _c.start());
                const maybeDescription = summaryReporter.getLifecycleDescriptions();
                if (maybeDescription.isErr()) {
                    return teamsfx_api_1.err(maybeDescription.error);
                }
                ctx.logProvider.info(`Executing deploy ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
                const execRes = await projectModel.deploy.execute(ctx);
                summaryReporter.updateLifecycleState(0, execRes);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                lodash_1.merge(output, result[0]);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return teamsfx_api_1.err(result[1]);
                }
                // show message box after deploy
                const botTroubleShootMsg = core_1.getBotTroubleShootMessage(false);
                const msg = localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.deploy", steps, steps) +
                    botTroubleShootMsg.textForLogging;
                if (ctx.platform !== teamsfx_api_1.Platform.VS) {
                    (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", msg, false);
                }
            }
            finally {
                const summary = summaryReporter.getLifecycleSummary();
                ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
                await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
            }
        }
        else {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError("deploy"));
        }
        return teamsfx_api_1.ok(output);
    }
    async publish(ctx, inputs, actionContext) {
        var _a, _b, _c, _d, _e;
        const output = {};
        const templatePath = pathUtils_1.pathUtils.getYmlFilePath(ctx.projectPath, inputs.env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(templatePath, inputs.env);
        if (maybeProjectModel.isErr()) {
            return teamsfx_api_1.err(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        let hasError = false;
        if (projectModel.publish) {
            const summaryReporter = new summary_1.SummaryReporter([projectModel.publish], ctx.logProvider);
            try {
                const steps = projectModel.publish.driverDefs.length;
                ctx.progressBar = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("core.progress.publish"), steps);
                await ((_b = ctx.progressBar) === null || _b === void 0 ? void 0 : _b.start());
                const maybeDescription = summaryReporter.getLifecycleDescriptions();
                if (maybeDescription.isErr()) {
                    hasError = true;
                    return teamsfx_api_1.err(maybeDescription.error);
                }
                ctx.logProvider.info(`Executing publish ${os_1.EOL}${os_1.EOL}${maybeDescription.value}${os_1.EOL}`);
                const execRes = await projectModel.publish.execute(ctx);
                const result = this.convertExecuteResult(execRes.result, templatePath);
                lodash_1.merge(output, result[0]);
                summaryReporter.updateLifecycleState(0, execRes);
                if (result[1]) {
                    hasError = true;
                    inputs.envVars = output;
                    return teamsfx_api_1.err(result[1]);
                }
                else {
                    const msg = localizeUtils_1.getLocalizedString("core.common.LifecycleComplete.publish", steps, steps);
                    const adminPortal = localizeUtils_1.getLocalizedString("plugins.appstudio.adminPortal");
                    if (ctx.platform !== teamsfx_api_1.Platform.CLI) {
                        (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", msg, false, adminPortal).then((value) => {
                            if (value.isOk() && value.value === adminPortal) {
                                ctx.ui.openUrl(constants_3.Constants.TEAMS_ADMIN_PORTAL);
                            }
                        });
                    }
                    else {
                        (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", msg, false);
                    }
                }
            }
            finally {
                const summary = summaryReporter.getLifecycleSummary();
                ctx.logProvider.info(`Execution summary:${os_1.EOL}${os_1.EOL}${summary}${os_1.EOL}`);
                await ((_e = ctx.progressBar) === null || _e === void 0 ? void 0 : _e.end(!hasError));
            }
        }
        else {
            return teamsfx_api_1.err(new yml_1.LifeCycleUndefinedError("publish"));
        }
        return teamsfx_api_1.ok(output);
    }
    async publishInDeveloperPortal(ctx, inputs, actionContext) {
        // update teams app
        if (!ctx.tokenProvider) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("tokenProvider"));
        }
        if (!inputs[question_1.CoreQuestionNames.AppPackagePath]) {
            return teamsfx_api_1.err(new error_1.ObjectIsUndefinedError("appPackagePath"));
        }
        const updateRes = await appStudio_1.updateTeamsAppV3ForPublish(ctx, inputs);
        if (updateRes.isErr()) {
            return teamsfx_api_1.err(updateRes.error);
        }
        let loginHint = "";
        const accountRes = await ctx.tokenProvider.m365TokenProvider.getJsonObject({
            scopes: constants_3.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        await ctx.userInteraction.openUrl(`https://dev.teams.microsoft.com/apps/${updateRes.value}/distributions/app-catalog?login_hint=${loginHint}&referrer=teamstoolkit_${inputs.platform}`);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.CreateProject,
            telemetryComponentName: "coordinator",
            errorSource: constants_1.CoordinatorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "create", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: "init-infra",
            telemetryComponentName: "coordinator",
            errorSource: constants_1.CoordinatorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "initInfra", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: "init-debug",
            telemetryComponentName: "coordinator",
            errorSource: constants_1.CoordinatorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "initDebug", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            question: (context, inputs) => {
                return question_3.getQuestionsForAddFeatureV3(context, inputs);
            },
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.AddFeature,
            telemetryComponentName: "coordinator",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "addFeature", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.Provision,
            telemetryComponentName: "coordinator",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.Deploy,
            telemetryComponentName: "coordinator",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "deploy", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: "publish",
            telemetryComponentName: "coordinator",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "publish", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.PublishInDeveloperPortal,
            telemetryComponentName: "coordinator",
            errorSource: constants_1.CoordinatorSource,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Coordinator.prototype, "publishInDeveloperPortal", null);
exports.Coordinator = Coordinator;
exports.coordinator = new Coordinator();
//# sourceMappingURL=index.js.map