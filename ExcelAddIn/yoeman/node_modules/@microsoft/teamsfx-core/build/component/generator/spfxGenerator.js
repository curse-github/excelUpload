"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxGenerator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const progress_helper_1 = require("../resource/spfx/utils/progress-helper");
const questions_1 = require("../resource/spfx/utils/questions");
const error_1 = require("../resource/spfx/error");
const utils_1 = require("../resource/spfx/utils/utils");
const lodash_1 = require("lodash");
const constants_1 = require("../resource/spfx/utils/constants");
const yoChecker_1 = require("../resource/spfx/depsChecker/yoChecker");
const generatorChecker_1 = require("../resource/spfx/depsChecker/generatorChecker");
const deps_checker_1 = require("../../common/deps-checker");
const telemetryEvents_1 = require("../resource/spfx/utils/telemetryEvents");
const generator_1 = require("./generator");
const question_1 = require("../../core/question");
const localizeUtils_1 = require("../../common/localizeUtils");
const question_helper_1 = require("../resource/spfx/utils/question-helper");
const constants_2 = require("../constants");
class SPFxGenerator {
    static async generate(context, inputs, destinationPath) {
        const yeomanRes = await this.doYeomanScaffold(context, inputs, destinationPath);
        if (yeomanRes.isErr())
            return teamsfx_api_1.err(yeomanRes.error);
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, constants_1.Constants.TEMPLATE_NAME, "ts");
        if (templateRes.isErr())
            return teamsfx_api_1.err(templateRes.error);
        return teamsfx_api_1.ok(undefined);
    }
    static async doYeomanScaffold(context, inputs, destinationPath) {
        var _a, _b;
        const ui = context.userInteraction;
        const progressHandler = await progress_helper_1.ProgressHelper.startScaffoldProgressHandler(ui, inputs.stage == teamsfx_api_1.Stage.addWebpart);
        const shouldInstallLocally = inputs[questions_1.SPFXQuestionNames.use_global_package_or_install_local] ===
            question_helper_1.SPFxVersionOptionIds.installLocally;
        try {
            const webpartName = inputs[questions_1.SPFXQuestionNames.webpart_name];
            const framework = inputs[questions_1.SPFXQuestionNames.framework_type];
            const solutionName = inputs[question_1.CoreQuestionNames.AppName];
            const isAddSPFx = inputs.stage == teamsfx_api_1.Stage.addWebpart;
            const componentName = utils_1.Utils.normalizeComponentName(webpartName);
            const componentNameCamelCase = lodash_1.camelCase(componentName);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("plugins.spfx.scaffold.dependencyCheck")));
            const yoChecker = new yoChecker_1.YoChecker(context.logProvider);
            const spGeneratorChecker = new generatorChecker_1.GeneratorChecker(context.logProvider);
            if (shouldInstallLocally) {
                const latestYoInstalled = await yoChecker.isLatestInstalled();
                const latestGeneratorInstalled = await spGeneratorChecker.isLatestInstalled();
                if (!latestYoInstalled || !latestGeneratorInstalled) {
                    await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("plugins.spfx.scaffold.dependencyInstall")));
                    if (!latestYoInstalled) {
                        const yoRes = await yoChecker.ensureLatestDependency(context);
                        if (yoRes.isErr()) {
                            throw error_1.LatestPackageInstallError();
                        }
                    }
                    if (!latestGeneratorInstalled) {
                        const spGeneratorRes = await spGeneratorChecker.ensureLatestDependency(context);
                        if (spGeneratorRes.isErr()) {
                            throw error_1.LatestPackageInstallError();
                        }
                    }
                }
            }
            else {
                const isLowerVersion = question_helper_1.PackageSelectOptionsHelper.isLowerThanRecommendedVersion();
                if (isLowerVersion) {
                    context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.UseNotRecommendedVersion);
                }
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString(isAddSPFx
                ? "driver.spfx.add.progress.scaffoldWebpart"
                : "plugins.spfx.scaffold.scaffoldProject")));
            if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                context.logProvider.outputChannel.show();
            }
            const yoEnv = process.env;
            if (yoEnv.PATH) {
                yoEnv.PATH = shouldInstallLocally
                    ? `${await (await yoChecker.getBinFolders()).join(path.delimiter)}${path.delimiter}${(_a = process.env.PATH) !== null && _a !== void 0 ? _a : ""}`
                    : process.env.PATH;
            }
            else {
                yoEnv.Path = shouldInstallLocally
                    ? `${await (await yoChecker.getBinFolders()).join(path.delimiter)}${path.delimiter}${(_b = process.env.Path) !== null && _b !== void 0 ? _b : ""}`
                    : process.env.Path;
            }
            const args = [
                shouldInstallLocally ? spGeneratorChecker.getSpGeneratorPath() : "@microsoft/sharepoint",
                "--skip-install",
                "true",
                "--component-type",
                "webpart",
                "--component-name",
                webpartName,
                "--environment",
                "spo",
                "--skip-feature-deployment",
                "true",
                "--is-domain-isolated",
                "false",
            ];
            if (framework) {
                args.push("--framework", framework);
            }
            if (solutionName) {
                args.push("--solution-name", solutionName);
            }
            try {
                await deps_checker_1.cpUtils.executeCommand(isAddSPFx ? inputs[constants_2.SPFxQuestionNames.SPFxFolder] : destinationPath, context.logProvider, {
                    timeout: 2 * 60 * 1000,
                    env: yoEnv,
                }, "yo", ...args);
            }
            catch (yoError) {
                if (yoError.message) {
                    context.logProvider.error(yoError.message);
                }
                throw error_1.YoGeneratorScaffoldError();
            }
            const newPath = path.join(destinationPath, "src");
            if (!isAddSPFx) {
                const currentPath = path.join(destinationPath, solutionName);
                await fs_extra_1.default.rename(currentPath, newPath);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("plugins.spfx.scaffold.updateManifest")));
            const manifestPath = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.manifest.json`;
            const manifest = await fs_extra_1.default.readFile(manifestPath, "utf8");
            let manifestString = manifest.toString();
            manifestString = manifestString.replace(`"supportedHosts": ["SharePointWebPart"]`, `"supportedHosts": ["SharePointWebPart", "TeamsPersonalApp", "TeamsTab"]`);
            await fs_extra_1.default.writeFile(manifestPath, manifestString);
            const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
            const manifestJson = JSON.parse(manifestString.replace(matchHashComment, "").trim());
            const componentId = manifestJson.id;
            if (!isAddSPFx) {
                if (!context.templateVariables) {
                    context.templateVariables = generator_1.Generator.getDefaultVariables(solutionName);
                }
                context.templateVariables["componentId"] = componentId;
                context.templateVariables["webpartName"] = webpartName;
            }
            // remove dataVersion() function, related issue: https://github.com/SharePoint/sp-dev-docs/issues/6469
            const webpartFile = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.ts`;
            const codeFile = await fs_extra_1.default.readFile(webpartFile, "utf8");
            let codeString = codeFile.toString();
            codeString = codeString.replace(`  protected get dataVersion(): Version {\r\n    return Version.parse('1.0');\r\n  }\r\n\r\n`, ``);
            codeString = codeString.replace(`import { Version } from '@microsoft/sp-core-library';\r\n`, ``);
            await fs_extra_1.default.writeFile(webpartFile, codeString);
            // remove .vscode
            const debugPath = `${newPath}/.vscode`;
            if (await fs_extra_1.default.pathExists(debugPath)) {
                await fs_extra_1.default.remove(debugPath);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
            return teamsfx_api_1.ok(componentId);
        }
        catch (error) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            return teamsfx_api_1.err(error_1.ScaffoldError(error));
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: constants_1.Constants.PLUGIN_DEV_NAME,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: constants_1.Constants.PLUGIN_DEV_NAME,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxGenerator, "generate", null);
exports.SPFxGenerator = SPFxGenerator;
//# sourceMappingURL=spfxGenerator.js.map