"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddWebPartDriver = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lib_1 = require("@feathersjs/hooks/lib");
const typedi_1 = require("typedi");
const wrapUtil_1 = require("../util/wrapUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const ManifestUtils_1 = require("../../resource/appManifest/utils/ManifestUtils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../utils/common");
const path_1 = tslib_1.__importDefault(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const util = tslib_1.__importStar(require("util"));
const constants_1 = require("../../resource/spfx/utils/constants");
const spfxGenerator_1 = require("../../generator/spfxGenerator");
const utils_1 = require("../../utils");
const constants_2 = require("./utility/constants");
const noConfigurationError_1 = require("./error/noConfigurationError");
const constants_3 = require("../../constants");
const questions_1 = require("../../resource/spfx/utils/questions");
let AddWebPartDriver = class AddWebPartDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.spfx.add.description");
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_2.Constants.ActionName, constants_2.Constants.ActionName);
        return common_1.wrapRun(() => this.add(args, wrapContext));
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_2.Constants.ActionName, constants_2.Constants.ActionName);
        const res = await this.run(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async add(args, context) {
        var _a;
        const webpartName = args.webpartName;
        const spfxFolder = args.spfxFolder;
        const manifestPath = args.manifestPath;
        const localManifestPath = args.localManifestPath;
        const spfxPackage = args.spfxPackage;
        const yorcPath = path_1.default.join(spfxFolder, constants_2.Constants.YO_RC_FILE);
        if (!(await fs.pathExists(yorcPath))) {
            throw new noConfigurationError_1.NoConfigurationError();
        }
        const inputs = { platform: context.platform, stage: teamsfx_api_1.Stage.addWebpart };
        inputs[constants_3.SPFxQuestionNames.WebPartName] = webpartName;
        inputs[constants_3.SPFxQuestionNames.SPFxFolder] = spfxFolder;
        inputs[constants_3.SPFxQuestionNames.ManifestPath] = manifestPath;
        inputs[constants_3.SPFxQuestionNames.LocalManifestPath] = localManifestPath;
        inputs[questions_1.SPFXQuestionNames.use_global_package_or_install_local] = spfxPackage;
        const yeomanRes = await spfxGenerator_1.SPFxGenerator.doYeomanScaffold(utils_1.createContextV3(), inputs, context.projectPath);
        if (yeomanRes.isErr())
            throw yeomanRes.error;
        const componentId = yeomanRes.value;
        const remoteStaticSnippet = {
            entityId: componentId,
            name: webpartName,
            contentUrl: util.format(constants_2.Constants.REMOTE_CONTENT_URL, componentId),
            websiteUrl: constants_1.ManifestTemplate.WEBSITE_URL,
            scopes: ["personal"],
        };
        const localStaticSnippet = {
            entityId: componentId,
            name: webpartName,
            contentUrl: util.format(constants_2.Constants.LOCAL_CONTENT_URL, componentId),
            websiteUrl: constants_1.ManifestTemplate.WEBSITE_URL,
            scopes: ["personal"],
        };
        inputs["addManifestPath"] = localManifestPath;
        const localRes = await ManifestUtils_1.manifestUtils.addCapabilities(Object.assign(Object.assign({}, inputs), { projectPath: context.projectPath }), [{ name: "staticTab", snippet: localStaticSnippet }]);
        if (localRes.isErr())
            throw localRes.error;
        inputs["addManifestPath"] = manifestPath;
        const remoteRes = await ManifestUtils_1.manifestUtils.addCapabilities(Object.assign(Object.assign({}, inputs), { projectPath: context.projectPath }), [{ name: "staticTab", snippet: remoteStaticSnippet }]);
        if (remoteRes.isErr())
            throw remoteRes.error;
        (_a = context.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", localizeUtils_1.getLocalizedString("driver.spfx.add.successNotice", webpartName), false);
        return new Map();
    }
};
tslib_1.__decorate([
    lib_1.hooks([addStartAndEndTelemetry_1.addStartAndEndTelemetry(constants_2.Constants.ActionName, constants_2.Constants.ActionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AddWebPartDriver.prototype, "run", null);
AddWebPartDriver = tslib_1.__decorate([
    typedi_1.Service(constants_2.Constants.ActionName)
], AddWebPartDriver);
exports.AddWebPartDriver = AddWebPartDriver;
//# sourceMappingURL=addWebPart.js.map