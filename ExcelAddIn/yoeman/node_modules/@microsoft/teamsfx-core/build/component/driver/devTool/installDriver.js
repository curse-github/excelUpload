"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolsInstallDriverImpl = exports.ToolsInstallDriver = void 0;
const tslib_1 = require("tslib");
/**
 * @author Xiaofu Huang <xiaofhua@microsoft.com>
 */
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const typedi_1 = require("typedi");
const deps_checker_1 = require("../../../common/deps-checker");
const localCertificateManager_1 = require("../../../common/local/localCertificateManager");
const common_1 = require("../../utils/common");
const wrapUtil_1 = require("../util/wrapUtil");
const constant_1 = require("./constant");
const dotnetInstallationUserError_1 = require("./error/dotnetInstallationUserError");
const funcInstallationUserError_1 = require("./error/funcInstallationUserError");
const common_2 = require("../../../error/common");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const updateProgress_1 = require("../middleware/updateProgress");
const lib_1 = require("@feathersjs/hooks/lib");
const localizeUtils_1 = require("../../../common/localizeUtils");
const funcToolChecker_1 = require("../../../common/deps-checker/internal/funcToolChecker");
const ACTION_NAME = "devTool/install";
const helpLink = "https://aka.ms/teamsfx-actions/devtool-install";
const outputKeys = {
    sslCertFile: "sslCertFile",
    sslKeyFile: "sslKeyFile",
    funcPath: "funcPath",
    dotnetPath: "dotnetPath",
};
let ToolsInstallDriver = class ToolsInstallDriver {
    constructor() {
        this.description = constant_1.toolsInstallDescription();
    }
    async run(args, context) {
        return common_1.wrapRun(async () => {
            const wrapContext = new wrapUtil_1.WrapDriverContext(context, ACTION_NAME, ACTION_NAME);
            const impl = new ToolsInstallDriverImpl(wrapContext);
            return await impl.run(args);
        });
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, ACTION_NAME, ACTION_NAME);
        const result = await common_1.wrapRun(async () => {
            const impl = new ToolsInstallDriverImpl(wrapContext);
            return await impl.run(args, outputEnvVarNames);
        });
        return {
            result: result,
            summaries: wrapContext.summaries,
        };
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(ACTION_NAME, ACTION_NAME),
        updateProgress_1.updateProgress(localizeUtils_1.getLocalizedString("driver.prerequisite.progressBar")),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ToolsInstallDriver.prototype, "run", null);
tslib_1.__decorate([
    lib_1.hooks([
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(ACTION_NAME, ACTION_NAME),
        updateProgress_1.updateProgress(localizeUtils_1.getLocalizedString("driver.prerequisite.progressBar")),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Map]),
    tslib_1.__metadata("design:returntype", Promise)
], ToolsInstallDriver.prototype, "execute", null);
ToolsInstallDriver = tslib_1.__decorate([
    typedi_1.Service(ACTION_NAME)
], ToolsInstallDriver);
exports.ToolsInstallDriver = ToolsInstallDriver;
class ToolsInstallDriverImpl {
    constructor(context) {
        this.context = context;
    }
    async run(args, outputEnvVarNames) {
        const res = new Map();
        this.validateArgs(args);
        this.setArgTelemetry(args);
        if (args.devCert) {
            const localCertRes = await this.resolveLocalCertificate(args.devCert.trust, outputEnvVarNames);
            localCertRes.forEach((v, k) => res.set(k, v));
        }
        if (args.func) {
            const funcRes = await this.resolveFuncCoreTools(`${args.func.version}`, args.func.symlinkDir, outputEnvVarNames);
            funcRes.forEach((v, k) => res.set(k, v));
        }
        if (args.dotnet) {
            const dotnetRes = await this.resolveDotnet(outputEnvVarNames);
            dotnetRes.forEach((v, k) => res.set(k, v));
        }
        return res;
    }
    async resolveLocalCertificate(trustDevCert, outputEnvVarNames) {
        const res = new Map();
        // Do not print any log in LocalCertificateManager, use the error message returned instead.
        const certManager = new localCertificateManager_1.LocalCertificateManager(this.context.ui);
        const localCertResult = await certManager.setupCertificate(trustDevCert);
        if (trustDevCert) {
            let name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.sslCertFile);
            if (name) {
                res.set(name, localCertResult.certPath);
            }
            name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.sslKeyFile);
            if (name) {
                res.set(name, localCertResult.keyPath);
            }
        }
        this.setDevCertTelemetry(trustDevCert, localCertResult);
        if (typeof localCertResult.isTrusted === "undefined") {
            this.context.logProvider.warning(constant_1.Summaries.devCertSkipped());
            this.context.addSummary(constant_1.Summaries.devCertSkipped());
        }
        else if (localCertResult.isTrusted === false) {
            throw localCertResult.error;
        }
        else {
            this.context.addSummary(constant_1.Summaries.devCertSuccess(trustDevCert));
        }
        return res;
    }
    async resolveFuncCoreTools(version, symlinkDir, outputEnvVarNames) {
        var _a;
        const res = new Map();
        const funcToolChecker = new funcToolChecker_1.FuncToolChecker();
        const funcStatus = await funcToolChecker.resolve({
            version: version,
            symlinkDir: symlinkDir,
            projectPath: this.context.projectPath,
        });
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.funcStatus, funcStatus);
        if (!funcStatus.isInstalled && funcStatus.error) {
            throw new funcInstallationUserError_1.FuncInstallationUserError(ACTION_NAME, funcStatus.error);
        }
        else if (funcStatus.error) {
            this.context.logProvider.warning(funcStatus.error.message);
            this.context.addSummary(constant_1.Summaries.funcSuccess(funcStatus.details.binFolders) + funcStatus.error.message);
        }
        else {
            this.context.addSummary(constant_1.Summaries.funcSuccess(funcStatus.details.binFolders));
        }
        if (((_a = funcStatus === null || funcStatus === void 0 ? void 0 : funcStatus.details) === null || _a === void 0 ? void 0 : _a.binFolders) !== undefined) {
            const funcBinFolder = funcStatus.details.binFolders.join(path.delimiter);
            const name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.funcPath);
            if (name) {
                res.set(name, funcBinFolder);
            }
        }
        return res;
    }
    async resolveDotnet(outputEnvVarNames) {
        var _a, _b, _c, _d;
        const res = new Map();
        const depsManager = new deps_checker_1.DepsManager(new deps_checker_1.EmptyLogger(), new deps_checker_1.EmptyTelemetry());
        const dotnetStatus = await depsManager.ensureDependency(deps_checker_1.DepsType.Dotnet, true);
        this.setDepsCheckTelemetry(constant_1.TelemetryProperties.dotnetStatus, dotnetStatus);
        if (!dotnetStatus.isInstalled && dotnetStatus.error) {
            throw new dotnetInstallationUserError_1.DotnetInstallationUserError(ACTION_NAME, dotnetStatus.error);
        }
        else if (dotnetStatus.error) {
            this.context.logProvider.warning((_a = dotnetStatus.error) === null || _a === void 0 ? void 0 : _a.message);
            this.context.addSummary((_b = dotnetStatus.error) === null || _b === void 0 ? void 0 : _b.message);
        }
        else {
            this.context.addSummary(constant_1.Summaries.dotnetSuccess((_c = dotnetStatus === null || dotnetStatus === void 0 ? void 0 : dotnetStatus.details) === null || _c === void 0 ? void 0 : _c.binFolders));
        }
        if (((_d = dotnetStatus === null || dotnetStatus === void 0 ? void 0 : dotnetStatus.details) === null || _d === void 0 ? void 0 : _d.binFolders) !== undefined) {
            const dotnetBinFolder = `${dotnetStatus.details.binFolders
                .map((f) => path.dirname(f))
                .join(path.delimiter)}`;
            const name = outputEnvVarNames === null || outputEnvVarNames === void 0 ? void 0 : outputEnvVarNames.get(outputKeys.dotnetPath);
            if (name) {
                res.set(name, dotnetBinFolder);
            }
        }
        return res;
    }
    validateArgs(args) {
        var _a, _b;
        if (!!args.devCert && typeof ((_a = args.devCert) === null || _a === void 0 ? void 0 : _a.trust) !== "boolean") {
            throw new common_2.InvalidActionInputError(ACTION_NAME, ["devCert.trust"], helpLink);
        }
        if (typeof args.func !== "undefined") {
            if (typeof args.func !== "object") {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["func"], helpLink);
            }
            if ((typeof args.func.version !== "string" && typeof args.func.version !== "number") ||
                !semver_1.default.validRange(`${(_b = args.func) === null || _b === void 0 ? void 0 : _b.version}`)) {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["func.version"], helpLink);
            }
            if (typeof args.func.symlinkDir !== "string" && typeof args.func.symlinkDir !== "undefined") {
                throw new common_2.InvalidActionInputError(ACTION_NAME, ["func.symlinkDir"], helpLink);
            }
        }
        if (!!args.dotnet && typeof args.dotnet !== "boolean") {
            throw new common_2.InvalidActionInputError(ACTION_NAME, ["dotnet"], helpLink);
        }
    }
    setArgTelemetry(args) {
        var _a, _b;
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.driverArgs]: JSON.stringify({
                devCert: args.devCert,
                func: {
                    version: (_a = args.func) === null || _a === void 0 ? void 0 : _a.version,
                    symlinkDir: ((_b = args.func) === null || _b === void 0 ? void 0 : _b.symlinkDir)
                        ? path.resolve(args.func.symlinkDir) === path.resolve("./devTools/func")
                            ? "<default>"
                            : "<unknown>"
                        : "<undefined>",
                },
                dotnet: args.dotnet,
            }),
        });
    }
    setDevCertTelemetry(trustDevCert, localCertResult) {
        this.context.addTelemetryProperties({
            [constant_1.TelemetryProperties.devCertStatus]: !trustDevCert
                ? constant_1.TelemetryDevCertStatus.Disabled
                : localCertResult.alreadyTrusted
                    ? constant_1.TelemetryDevCertStatus.AlreadyTrusted
                    : localCertResult.isTrusted
                        ? constant_1.TelemetryDevCertStatus.Trusted
                        : constant_1.TelemetryDevCertStatus.NotTrusted,
        });
    }
    setDepsCheckTelemetry(propertyName, depStatus) {
        this.context.addTelemetryProperties({
            [propertyName]: depStatus.isInstalled
                ? depStatus.error
                    ? constant_1.TelemetryDepsCheckStatus.warn
                    : constant_1.TelemetryDepsCheckStatus.success
                : constant_1.TelemetryDepsCheckStatus.failed,
        });
        if (depStatus.telemetryProperties) {
            this.context.addTelemetryProperties(depStatus.telemetryProperties);
        }
    }
}
exports.ToolsInstallDriverImpl = ToolsInstallDriverImpl;
//# sourceMappingURL=installDriver.js.map