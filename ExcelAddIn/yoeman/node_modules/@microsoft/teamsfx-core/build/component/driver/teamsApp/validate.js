"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateManifestDriver = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lib_1 = require("@feathersjs/hooks/lib");
const typedi_1 = require("typedi");
const os_1 = require("os");
const wrapUtil_1 = require("../util/wrapUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const telemetry_1 = require("../../resource/appManifest/utils/telemetry");
const results_1 = require("../../resource/appManifest/results");
const errors_1 = require("../../resource/appManifest/errors");
const ManifestUtils_1 = require("../../resource/appManifest/utils/ManifestUtils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("../../../common/constants");
const common_1 = require("../../utils/common");
const constant_1 = require("../../configManager/constant");
const updateProgress_1 = require("../middleware/updateProgress");
const common_2 = require("../../../error/common");
const actionName = "teamsApp/validateManifest";
let ValidateManifestDriver = class ValidateManifestDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.teamsApp.description.validateDriver");
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.validate(args, wrapContext);
        return res;
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.validate(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async validate(args, context) {
        var _a, _b, _c;
        telemetry_1.TelemetryUtils.init(context);
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        const state = this.loadCurrentState();
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(common_1.getAbsolutePath(args.manifestPath, context.projectPath), state);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const manifest = manifestRes.value;
        let validationResult;
        if (manifest.$schema) {
            try {
                validationResult = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
            }
            catch (e) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    localizeUtils_1.getLocalizedString("error.appstudio.validateFetchSchemaFailed", manifest.$schema, e.message),
                ]), constants_1.HelpLinks.WhyNeedProvision));
            }
        }
        else {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                localizeUtils_1.getLocalizedString("error.appstudio.validateSchemaNotDefined"),
            ]), constants_1.HelpLinks.WhyNeedProvision));
        }
        if (validationResult.length > 0) {
            const summaryStr = localizeUtils_1.getLocalizedString("driver.teamsApp.summary.validate.failed", validationResult.length);
            // logs in output window
            const errors = validationResult
                .map((error) => {
                return `${constant_1.SummaryConstant.Failed} ${error}`;
            })
                .join(os_1.EOL);
            const outputMessage = os_1.EOL + localizeUtils_1.getLocalizedString("driver.teamsApp.summary.validateManifest", summaryStr, errors);
            (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.info(outputMessage);
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, [
                localizeUtils_1.getDefaultString("driver.teamsApp.validate.result", summaryStr),
                localizeUtils_1.getLocalizedString("driver.teamsApp.validate.result.display", summaryStr),
            ]));
        }
        else {
            // logs in output window
            const summaryStr = localizeUtils_1.getLocalizedString("driver.teamsApp.summary.validate.succeed", localizeUtils_1.getLocalizedString("driver.teamsApp.summary.validate.all"));
            const outputMessage = os_1.EOL + localizeUtils_1.getLocalizedString("driver.teamsApp.summary.validateManifest", summaryStr, "");
            (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.info(outputMessage);
            const validationSuccess = localizeUtils_1.getLocalizedString("driver.teamsApp.validate.result.display", summaryStr);
            if (context.platform === teamsfx_api_1.Platform.VS) {
                context.logProvider.info(validationSuccess);
            }
            if (args.showMessage) {
                (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", validationSuccess, false);
            }
            return teamsfx_api_1.ok(new Map());
        }
    }
    loadCurrentState() {
        return {
            ENV_NAME: process.env.TEAMSFX_ENV,
        };
    }
    validateArgs(args) {
        if (!args || !args.manifestPath) {
            return teamsfx_api_1.err(new common_2.InvalidActionInputError(actionName, ["manifestPath"], "https://aka.ms/teamsfx-actions/teamsapp-validate"));
        }
        return teamsfx_api_1.ok(undefined);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(actionName, actionName),
        updateProgress_1.updateProgress(localizeUtils_1.getLocalizedString("plugins.appstudio.validateManifest.progressBar.message")),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], ValidateManifestDriver.prototype, "validate", null);
ValidateManifestDriver = tslib_1.__decorate([
    typedi_1.Service(actionName)
], ValidateManifestDriver);
exports.ValidateManifestDriver = ValidateManifestDriver;
//# sourceMappingURL=validate.js.map