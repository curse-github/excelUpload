"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxDeployDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const tools_1 = require("../../../../common/tools");
const common_1 = require("../../../../error/common");
const common_2 = require("../../../utils/common");
const addStartAndEndTelemetry_1 = require("../../middleware/addStartAndEndTelemetry");
const updateProgress_1 = require("../../middleware/updateProgress");
const wrapUtil_1 = require("../../util/wrapUtil");
const createAppCatalogFailedError_1 = require("./error/createAppCatalogFailedError");
const getGraphTokenFailedError_1 = require("./error/getGraphTokenFailedError");
const getSPOTokenFailedError_1 = require("./error/getSPOTokenFailedError");
const getTenantFailedError_1 = require("./error/getTenantFailedError");
const insufficientPermissionError_1 = require("./error/insufficientPermissionError");
const noSPPackageError_1 = require("./error/noSPPackageError");
const noValidAppCatelogError_1 = require("./error/noValidAppCatelogError");
const uploadAppPackageFailedError_1 = require("./error/uploadAppPackageFailedError");
const constants_1 = require("./utility/constants");
const sleep_1 = require("./utility/sleep");
const spoClient_1 = require("./utility/spoClient");
let SPFxDeployDriver = class SPFxDeployDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.spfx.deploy.description");
        this.EmptyMap = new Map();
        this.asDeployArgs = common_2.asFactory({
            createAppCatalogIfNotExist: common_2.asBoolean,
            packageSolutionPath: common_2.asString,
        });
    }
    async run(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName);
        return common_2.wrapRun(() => this.deploy(args, wrapContext));
    }
    async execute(args, ctx) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(ctx, constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName);
        const result = await this.run(args, wrapContext);
        return {
            result,
            summaries: wrapContext.summaries,
        };
    }
    async deploy(args, context) {
        var _a, _b, _c;
        const deployArgs = this.asDeployArgs(args);
        const tenant = await this.getTenant(context.m365TokenProvider);
        spoClient_1.SPOClient.setBaseUrl(tenant);
        const spoToken = await tools_1.getSPFxToken(context.m365TokenProvider);
        if (!spoToken) {
            throw new getSPOTokenFailedError_1.GetSPOTokenFailedError();
        }
        let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
        if (appCatalogSite) {
            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            context.addSummary(constants_1.DeployProgressMessage.SkipCreateSPAppCatalog());
        }
        else {
            if (deployArgs.createAppCatalogIfNotExist) {
                try {
                    await spoClient_1.SPOClient.createAppCatalog(spoToken);
                    context.addSummary(constants_1.DeployProgressMessage.CreateSPAppCatalog());
                }
                catch (e) {
                    throw new createAppCatalogFailedError_1.CreateAppCatalogFailedError(e);
                }
            }
            else {
                throw new noValidAppCatelogError_1.NoValidAppCatelog();
            }
            let retry = 0;
            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                context.logProvider.warning(localizeUtils_1.getLocalizedString("driver.spfx.warn.noTenantAppCatalogFound", retry));
                await sleep_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                retry += 1;
            }
            if (appCatalogSite) {
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                context.logProvider.info(localizeUtils_1.getLocalizedString("driver.spfx.info.tenantAppCatalogCreated", appCatalogSite));
                await sleep_1.sleep(constants_1.Constants.APP_CATALOG_ACTIVE_TIME);
            }
            else {
                throw new createAppCatalogFailedError_1.CreateAppCatalogFailedError(new Error(localizeUtils_1.getLocalizedString("driver.spfx.error.failedToGetAppCatalog")));
            }
        }
        const packageSolutionPath = path_1.default.isAbsolute(deployArgs.packageSolutionPath)
            ? deployArgs.packageSolutionPath
            : path_1.default.join(context.projectPath, deployArgs.packageSolutionPath);
        const appPackage = await this.getPackagePath(packageSolutionPath);
        if (!(await fs_extra_1.default.pathExists(appPackage))) {
            throw new noSPPackageError_1.NoSPPackageError(appPackage);
        }
        const fileName = path_1.default.parse(appPackage).base;
        const bytes = await fs_extra_1.default.readFile(appPackage);
        try {
            await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            context.addSummary(constants_1.DeployProgressMessage.Upload());
        }
        catch (e) {
            if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 403) {
                throw new insufficientPermissionError_1.InsufficientPermissionError(appCatalogSite);
            }
            else {
                throw new uploadAppPackageFailedError_1.UploadAppPackageFailedError(e);
            }
        }
        const appID = await this.getAppID(packageSolutionPath);
        await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
        context.addSummary(constants_1.DeployProgressMessage.Deploy());
        const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
        if (context.platform === teamsfx_api_1.Platform.CLI) {
            (_b = context.ui) === null || _b === void 0 ? void 0 : _b.showMessage("info", guidance, false);
        }
        else {
            (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", guidance, false, "OK");
        }
        return this.EmptyMap;
    }
    async getTenant(tokenProvider) {
        const graphTokenRes = await tokenProvider.getAccessToken({
            scopes: tools_1.GraphScopes,
        });
        const graphToken = graphTokenRes.isOk() ? graphTokenRes.value : undefined;
        if (!graphToken) {
            throw new getGraphTokenFailedError_1.GetGraphTokenFailedError();
        }
        const tokenJsonRes = await tokenProvider.getJsonObject({
            scopes: tools_1.GraphScopes,
        });
        const username = tokenJsonRes.value.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                throw new getTenantFailedError_1.GetTenantFailedError(username);
            }
        }
        catch (e) {
            throw new getTenantFailedError_1.GetTenantFailedError(username, e);
        }
        return tenant;
    }
    async getPackagePath(solutionConfigPath) {
        if (!(await fs_extra_1.default.pathExists(solutionConfigPath))) {
            throw new common_1.FileNotFoundError(constants_1.Constants.DeployDriverName, solutionConfigPath);
        }
        const solutionConfig = await fs_extra_1.default.readJson(solutionConfigPath);
        const sharepointFolder = path_1.default.dirname(solutionConfigPath).replace("config", "sharepoint");
        return path_1.default.resolve(sharepointFolder, solutionConfig.paths.zippedPackage);
    }
    async getAppID(solutionConfigPath) {
        if (!(await fs_extra_1.default.pathExists(solutionConfigPath))) {
            throw new common_1.FileNotFoundError(constants_1.Constants.DeployDriverName, solutionConfigPath);
        }
        const solutionConfig = await fs_extra_1.default.readJson(solutionConfigPath);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(constants_1.Constants.TelemetryDeployEventName, constants_1.Constants.TelemetryComponentName),
        updateProgress_1.updateProgress(localizeUtils_1.getLocalizedString("driver.spfx.deploy.progressbar.stepMessage")),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxDeployDriver.prototype, "run", null);
SPFxDeployDriver = tslib_1.__decorate([
    typedi_1.Service(constants_1.Constants.DeployDriverName)
], SPFxDeployDriver);
exports.SPFxDeployDriver = SPFxDeployDriver;
//# sourceMappingURL=deployDriver.js.map