"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelManagementHttpClient = void 0;
const dev_tunnels_contracts_1 = require("@microsoft/dev-tunnels-contracts");
const tunnelManagementClient_1 = require("./tunnelManagementClient");
const tunnelAccessTokenProperties_1 = require("./tunnelAccessTokenProperties");
const version_1 = require("./version");
const axios_1 = require("axios");
const apiV1Path = `/api/v1`;
const tunnelsApiPath = apiV1Path + '/tunnels';
const limitsApiPath = apiV1Path + '/userlimits';
const endpointsApiSubPath = '/endpoints';
const portsApiSubPath = '/ports';
const clustersApiPath = apiV1Path + '/clusters';
const tunnelAuthentication = 'Authorization';
const checkAvailablePath = '/checkAvailability';
function comparePorts(a, b) {
    var _a, _b;
    return ((_a = a.portNumber) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER) - ((_b = b.portNumber) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER);
}
function parseDate(value) {
    return typeof value === 'string' ? new Date(Date.parse(value)) : value;
}
/**
 * Fixes Tunnel properties of type Date that were deserialized as strings.
 */
function parseTunnelDates(tunnel) {
    if (!tunnel)
        return;
    tunnel.created = parseDate(tunnel.created);
    if (tunnel.status) {
        tunnel.status.lastHostConnectionTime = parseDate(tunnel.status.lastHostConnectionTime);
        tunnel.status.lastClientConnectionTime = parseDate(tunnel.status.lastClientConnectionTime);
    }
}
/**
 * Fixes TunnelPort properties of type Date that were deserialized as strings.
 */
function parseTunnelPortDates(port) {
    if (!port)
        return;
    if (port.status) {
        port.status.lastClientConnectionTime = parseDate(port.status.lastClientConnectionTime);
    }
}
const manageAccessTokenScope = [dev_tunnels_contracts_1.TunnelAccessScopes.Manage];
const hostAccessTokenScope = [dev_tunnels_contracts_1.TunnelAccessScopes.Host];
const managePortsAccessTokenScopes = [
    dev_tunnels_contracts_1.TunnelAccessScopes.Manage,
    dev_tunnels_contracts_1.TunnelAccessScopes.ManagePorts,
    dev_tunnels_contracts_1.TunnelAccessScopes.Host,
];
const readAccessTokenScopes = [
    dev_tunnels_contracts_1.TunnelAccessScopes.Manage,
    dev_tunnels_contracts_1.TunnelAccessScopes.ManagePorts,
    dev_tunnels_contracts_1.TunnelAccessScopes.Host,
    dev_tunnels_contracts_1.TunnelAccessScopes.Connect,
];
class TunnelManagementHttpClient {
    /**
     * Initializes a new instance of the `TunnelManagementHttpClient` class
     * with a client authentication callback, service URI, and HTTP handler.
     *
     * @param userAgent { name, version } object or a comment string to use as the User-Agent header.
     * @param userTokenCallback Optional async callback for retrieving a client authentication
     * header value with access token, for AAD or GitHub user authentication. This may be omitted
     * for anonymous tunnel clients, or if tunnel access tokens will be specified via
     * `TunnelRequestOptions.accessToken`.
     * @param tunnelServiceUri Optional tunnel service URI (not including any path). Defaults to
     * the global tunnel service URI.
     * @param httpsAgent Optional agent that will be invoked for HTTPS requests to the tunnel
     * service.
     * @param adapter Optional axios adapter to use for HTTP requests.
     */
    constructor(userAgents, userTokenCallback, tunnelServiceUri, httpsAgent, adapter) {
        var _a;
        this.httpsAgent = httpsAgent;
        this.adapter = adapter;
        this.trace = (msg) => { };
        if (!userAgents) {
            throw new TypeError('User agent must be provided.');
        }
        if (Array.isArray(userAgents)) {
            if (userAgents.length === 0) {
                throw new TypeError('User agents cannot be empty.');
            }
            let combinedUserAgents = '';
            userAgents.forEach((userAgent) => {
                var _a;
                if (typeof userAgent !== 'string') {
                    if (!userAgent.name) {
                        throw new TypeError('Invalid user agent. The name must be provided.');
                    }
                    if (typeof userAgent.name !== 'string') {
                        throw new TypeError('Invalid user agent. The name must be a string.');
                    }
                    if (userAgent.version && typeof userAgent.version !== 'string') {
                        throw new TypeError('Invalid user agent. The version must be a string.');
                    }
                    combinedUserAgents = `${combinedUserAgents}${userAgent.name}/${(_a = userAgent.version) !== null && _a !== void 0 ? _a : 'unknown'} `;
                }
                else {
                    combinedUserAgents = `${combinedUserAgents}${userAgent} `;
                }
            });
            this.userAgents = combinedUserAgents.trim();
        }
        else if (typeof userAgents !== 'string') {
            if (!userAgents.name) {
                throw new TypeError('Invalid user agent. The name must be provided.');
            }
            if (typeof userAgents.name !== 'string') {
                throw new TypeError('Invalid user agent. The name must be a string.');
            }
            if (userAgents.version && typeof userAgents.version !== 'string') {
                throw new TypeError('Invalid user agent. The version must be a string.');
            }
            this.userAgents = `${userAgents.name}/${(_a = userAgents.version) !== null && _a !== void 0 ? _a : 'unknown'}`;
        }
        else {
            this.userAgents = userAgents;
        }
        this.userTokenCallback = userTokenCallback !== null && userTokenCallback !== void 0 ? userTokenCallback : (() => Promise.resolve(null));
        if (!tunnelServiceUri) {
            tunnelServiceUri = dev_tunnels_contracts_1.TunnelServiceProperties.production.serviceUri;
        }
        const parsedUri = new URL(tunnelServiceUri);
        if (!parsedUri || parsedUri.pathname !== '/') {
            throw new TypeError(`Invalid tunnel service URI: ${tunnelServiceUri}`);
        }
        this.baseAddress = tunnelServiceUri;
    }
    async listTunnels(clusterId, domain, options) {
        const queryParams = [clusterId ? null : 'global=true', domain ? `domain=${domain}` : null];
        const query = queryParams.filter((p) => !!p).join('&');
        const results = (await this.sendRequest('GET', clusterId, tunnelsApiPath, query, options));
        results.forEach(parseTunnelDates);
        return results;
    }
    async getTunnel(tunnel, options) {
        const result = await this.sendTunnelRequest('GET', tunnel, readAccessTokenScopes, undefined, undefined, options);
        parseTunnelDates(result);
        return result;
    }
    async createTunnel(tunnel, options) {
        const tunnelId = tunnel.tunnelId;
        if (tunnelId) {
            throw new Error('An ID may not be specified when creating a tunnel.');
        }
        tunnel = this.convertTunnelForRequest(tunnel);
        const result = (await this.sendRequest('POST', tunnel.clusterId, tunnelsApiPath, undefined, options, tunnel));
        parseTunnelDates(result);
        return result;
    }
    async updateTunnel(tunnel, options) {
        const result = (await this.sendTunnelRequest('PUT', tunnel, manageAccessTokenScope, undefined, undefined, options, this.convertTunnelForRequest(tunnel)));
        if (!(options === null || options === void 0 ? void 0 : options.tokenScopes)) {
            // If no new tokens were requested in the update, preserve any existing
            // access tokens in the resulting tunnel object.
            result.accessTokens = tunnel.accessTokens;
        }
        parseTunnelDates(result);
        return result;
    }
    async deleteTunnel(tunnel, options) {
        return await this.sendTunnelRequest('DELETE', tunnel, manageAccessTokenScope, undefined, undefined, options, undefined, true);
    }
    async updateTunnelEndpoint(tunnel, endpoint, options) {
        const path = `${endpointsApiSubPath}/${endpoint.hostId}/${endpoint.connectionMode}`;
        const result = (await this.sendTunnelRequest('PUT', tunnel, hostAccessTokenScope, path, undefined, options, endpoint));
        if (tunnel.endpoints) {
            // Also update the endpoint in the local tunnel object.
            tunnel.endpoints = tunnel.endpoints
                .filter((e) => e.hostId !== endpoint.hostId ||
                e.connectionMode !== endpoint.connectionMode)
                .concat(result);
        }
        return result;
    }
    async deleteTunnelEndpoints(tunnel, hostId, connectionMode, options) {
        const path = connectionMode == null
            ? `${endpointsApiSubPath}/${hostId}`
            : `${endpointsApiSubPath}/${hostId}/${connectionMode}`;
        const result = await this.sendTunnelRequest('DELETE', tunnel, hostAccessTokenScope, path, undefined, options, undefined, true);
        if (result && tunnel.endpoints) {
            // Also delete the endpoint in the local tunnel object.
            tunnel.endpoints = tunnel.endpoints.filter((e) => e.hostId !== hostId || e.connectionMode !== connectionMode);
        }
        return result;
    }
    async listUserLimits() {
        const results = await this.sendRequest('GET', undefined, limitsApiPath, undefined, undefined);
        return results || [];
    }
    async listTunnelPorts(tunnel, options) {
        const results = (await this.sendTunnelRequest('GET', tunnel, readAccessTokenScopes, portsApiSubPath, undefined, options));
        results.forEach(parseTunnelPortDates);
        return results;
    }
    async getTunnelPort(tunnel, portNumber, options) {
        const path = `${portsApiSubPath}/${portNumber}`;
        const result = await this.sendTunnelRequest('GET', tunnel, readAccessTokenScopes, path, undefined, options);
        parseTunnelPortDates(result);
        return result;
    }
    async createTunnelPort(tunnel, tunnelPort, options) {
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const result = (await this.sendTunnelRequest('POST', tunnel, managePortsAccessTokenScopes, portsApiSubPath, undefined, options, tunnelPort));
        if (tunnel.ports) {
            // Also add the port to the local tunnel object.
            tunnel.ports = tunnel.ports
                .filter((p) => p.portNumber !== tunnelPort.portNumber)
                .concat(result)
                .sort(comparePorts);
        }
        parseTunnelPortDates(result);
        return result;
    }
    async updateTunnelPort(tunnel, tunnelPort, options) {
        if (tunnelPort.clusterId && tunnel.clusterId && tunnelPort.clusterId !== tunnel.clusterId) {
            throw new Error('Tunnel port cluster ID is not consistent.');
        }
        const portNumber = tunnelPort.portNumber;
        const path = `${portsApiSubPath}/${portNumber}`;
        tunnelPort = this.convertTunnelPortForRequest(tunnel, tunnelPort);
        const result = (await this.sendTunnelRequest('PUT', tunnel, managePortsAccessTokenScopes, path, undefined, options, tunnelPort));
        if (tunnel.ports) {
            // Also update the port in the local tunnel object.
            tunnel.ports = tunnel.ports
                .filter((p) => p.portNumber !== tunnelPort.portNumber)
                .concat(result)
                .sort(comparePorts);
        }
        if (!(options === null || options === void 0 ? void 0 : options.tokenScopes)) {
            // If no new tokens were requested in the update, preserve any existing
            // access tokens in the resulting port object.
            result.accessTokens = tunnelPort.accessTokens;
        }
        parseTunnelPortDates(result);
        return result;
    }
    async deleteTunnelPort(tunnel, portNumber, options) {
        const path = `${portsApiSubPath}/${portNumber}`;
        const result = await this.sendTunnelRequest('DELETE', tunnel, managePortsAccessTokenScopes, path, undefined, options, undefined, true);
        if (result && tunnel.ports) {
            // Also delete the port in the local tunnel object.
            tunnel.ports = tunnel.ports
                .filter((p) => p.portNumber !== portNumber)
                .sort(comparePorts);
        }
        return result;
    }
    async listClusters() {
        return (await this.sendRequest('GET', undefined, clustersApiPath, undefined, undefined, undefined, false));
    }
    /**
     * Sends an HTTP request to the tunnel management API, targeting a specific tunnel.
     * This protected method enables subclasses to support additional tunnel management APIs.
     * @param method HTTP request method.
     * @param tunnel Tunnel that the request is targeting.
     * @param accessTokenScopes Required array of access scopes for tokens in `tunnel.accessTokens`
     * that could be used to authorize the request.
     * @param path Optional request sub-path relative to the tunnel.
     * @param query Optional query string to append to the request.
     * @param options Request options.
     * @param body Optional request body object.
     * @param allowNotFound If true, a 404 response is returned as a null or false result
     * instead of an error.
     * @returns Result of the request.
     */
    async sendTunnelRequest(method, tunnel, accessTokenScopes, path, query, options, body, allowNotFound) {
        const uri = this.buildUriForTunnel(tunnel, path, query, options);
        const config = await this.getAxiosRequestConfig(tunnel, options, accessTokenScopes);
        const result = await this.request(method, uri, body, config, allowNotFound);
        return result;
    }
    /**
     * Sends an HTTP request to the tunnel management API.
     * This protected method enables subclasses to support additional tunnel management APIs.
     * @param method HTTP request method.
     * @param clusterId Optional tunnel service cluster ID to direct the request to. If unspecified,
     * the request will use the global traffic-manager to find the nearest cluster.
     * @param path Required request path.
     * @param query Optional query string to append to the request.
     * @param options Request options.
     * @param body Optional request body object.
     * @param allowNotFound If true, a 404 response is returned as a null or false result
     * instead of an error.
     * @returns Result of the request.
     */
    async sendRequest(method, clusterId, path, query, options, body, allowNotFound) {
        const uri = this.buildUri(clusterId, path, query, options);
        const config = await this.getAxiosRequestConfig(undefined, options);
        const result = await this.request(method, uri, body, config, allowNotFound);
        return result;
    }
    async checkNameAvailablility(tunnelName) {
        tunnelName = encodeURI(tunnelName);
        const uri = this.buildUri(undefined, `${tunnelsApiPath}/${tunnelName}${checkAvailablePath}`);
        const config = {
            httpsAgent: this.httpsAgent,
            adapter: this.adapter,
        };
        return await this.request('GET', uri, undefined, config);
    }
    getResponseErrorMessage(error) {
        var _a, _b, _c, _d;
        let errorMessage = '';
        if ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) {
            const problemDetails = error.response.data;
            if (problemDetails.title || problemDetails.detail) {
                errorMessage = `Tunnel service error: ${problemDetails.title}`;
                if (problemDetails.detail) {
                    errorMessage += ' ' + problemDetails.detail;
                }
                if (problemDetails.errors) {
                    errorMessage += JSON.stringify(problemDetails.errors);
                }
            }
        }
        if (!errorMessage) {
            if (error === null || error === void 0 ? void 0 : error.response) {
                errorMessage =
                    'Tunnel service returned status code: ' +
                        `${error.response.status} ${error.response.statusText}`;
            }
            else {
                errorMessage = (_c = (_b = error === null || error === void 0 ? void 0 : error.message) !== null && _b !== void 0 ? _b : error) !== null && _c !== void 0 ? _c : 'Unknown tunnel service request error.';
            }
        }
        const requestIdHeaderName = 'VsSaaS-Request-Id';
        if (((_d = error.response) === null || _d === void 0 ? void 0 : _d.headers) && error.response.headers[requestIdHeaderName]) {
            errorMessage += `\nRequest ID: ${error.response.headers[requestIdHeaderName]}`;
        }
        return errorMessage;
    }
    // Helper functions
    buildUri(clusterId, path, query, options) {
        let baseAddress = this.baseAddress;
        if (clusterId) {
            const url = new URL(baseAddress);
            const portNumber = parseInt(url.port, 10);
            if (url.hostname !== 'localhost' && !url.hostname.startsWith(`${clusterId}.`)) {
                // A specific cluster ID was specified (while not running on localhost).
                // Prepend the cluster ID to the hostname, and optionally strip a global prefix.
                url.hostname = `${clusterId}.${url.hostname}`.replace('global.', '');
                baseAddress = url.toString();
            }
            else if (url.protocol === 'https:' &&
                clusterId.startsWith('localhost') &&
                portNumber % 10 > 0) {
                // Local testing simulates clusters by running the service on multiple ports.
                // Change the port number to match the cluster ID suffix.
                const clusterNumber = parseInt(clusterId.substring('localhost'.length), 10);
                if (clusterNumber > 0 && clusterNumber < 10) {
                    url.port = (portNumber - (portNumber % 10) + clusterNumber).toString();
                    baseAddress = url.toString();
                }
            }
        }
        baseAddress = `${baseAddress.replace(/\/$/, '')}${path}`;
        const optionsQuery = this.tunnelRequestOptionsToQueryString(options, query);
        if (optionsQuery) {
            baseAddress += `?${optionsQuery}`;
        }
        return baseAddress;
    }
    buildUriForTunnel(tunnel, path, query, options) {
        let tunnelPath = '';
        if (tunnel.clusterId && tunnel.tunnelId) {
            tunnelPath = `${tunnelsApiPath}/${tunnel.tunnelId}`;
        }
        else {
            if (!tunnel.name) {
                throw new Error('Tunnel object must include either a name or tunnel ID and cluster ID.');
            }
            tunnelPath = `${tunnelsApiPath}/${tunnel.name}`;
        }
        if (options === null || options === void 0 ? void 0 : options.additionalQueryParameters) {
            for (const [paramName, paramValue] of Object.entries(options.additionalQueryParameters)) {
                if (query) {
                    query += `&${paramName}=${paramValue}`;
                }
                else {
                    query = `${paramName}=${paramValue}`;
                }
            }
        }
        return this.buildUri(tunnel.clusterId, tunnelPath + (path ? path : ''), query, options);
    }
    async getAxiosRequestConfig(tunnel, options, accessTokenScopes) {
        // Get access token header
        const headers = {};
        if (options && options.accessToken) {
            tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.validateTokenExpiration(options.accessToken);
            headers[tunnelAuthentication] = `${tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel} ${options.accessToken}`;
        }
        if (!(tunnelAuthentication in headers) && this.userTokenCallback) {
            const token = await this.userTokenCallback();
            if (token) {
                headers[tunnelAuthentication] = token;
            }
        }
        if (!(tunnelAuthentication in headers)) {
            const accessToken = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.getTunnelAccessToken(tunnel, accessTokenScopes);
            if (accessToken) {
                headers[tunnelAuthentication] = `${tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel} ${accessToken}`;
            }
        }
        const copyAdditionalHeaders = (additionalHeaders) => {
            if (additionalHeaders) {
                for (const [headerName, headerValue] of Object.entries(additionalHeaders)) {
                    headers[headerName] = headerValue;
                }
            }
        };
        copyAdditionalHeaders(this.additionalRequestHeaders);
        copyAdditionalHeaders(options === null || options === void 0 ? void 0 : options.additionalHeaders);
        const userAgentPrefix = headers['User-Agent'] ? headers['User-Agent'] + ' ' : '';
        headers['User-Agent'] = `${userAgentPrefix}${this.userAgents} ${version_1.tunnelSdkUserAgent}`;
        // Get axios config
        const config = Object.assign(Object.assign({ headers }, (this.httpsAgent && { httpsAgent: this.httpsAgent })), (this.adapter && { adapter: this.adapter }));
        if ((options === null || options === void 0 ? void 0 : options.followRedirects) === false) {
            config.maxRedirects = 0;
        }
        return config;
    }
    convertTunnelForRequest(tunnel) {
        var _a;
        const convertedTunnel = {
            name: tunnel.name,
            domain: tunnel.domain,
            description: tunnel.description,
            tags: tunnel.tags,
            options: tunnel.options,
            accessControl: !tunnel.accessControl
                ? undefined
                : { entries: tunnel.accessControl.entries.filter((ace) => !ace.isInherited) },
            endpoints: tunnel.endpoints,
            ports: (_a = tunnel.ports) === null || _a === void 0 ? void 0 : _a.map((p) => this.convertTunnelPortForRequest(tunnel, p)),
        };
        return convertedTunnel;
    }
    convertTunnelPortForRequest(tunnel, tunnelPort) {
        if (tunnelPort.clusterId && tunnel.clusterId && tunnelPort.clusterId !== tunnel.clusterId) {
            throw new Error('Tunnel port cluster ID does not match tunnel.');
        }
        if (tunnelPort.tunnelId && tunnel.tunnelId && tunnelPort.tunnelId !== tunnel.tunnelId) {
            throw new Error('Tunnel port tunnel ID does not match tunnel.');
        }
        return {
            portNumber: tunnelPort.portNumber,
            protocol: tunnelPort.protocol,
            isDefault: tunnelPort.isDefault,
            description: tunnelPort.description,
            tags: tunnelPort.tags,
            sshUser: tunnelPort.sshUser,
            options: tunnelPort.options,
            accessControl: !tunnelPort.accessControl
                ? undefined
                : { entries: tunnelPort.accessControl.entries.filter((ace) => !ace.isInherited) },
        };
    }
    tunnelRequestOptionsToQueryString(options, additionalQuery) {
        const queryOptions = {};
        const queryItems = [];
        if (options) {
            if (options.includePorts) {
                queryOptions.includePorts = ['true'];
            }
            if (options.includeAccessControl) {
                queryOptions.includeAccessControl = ['true'];
            }
            if (options.tokenScopes) {
                dev_tunnels_contracts_1.TunnelAccessControl.validateScopes(options.tokenScopes, undefined, true);
                queryOptions.tokenScopes = options.tokenScopes;
            }
            if (options.forceRename) {
                queryOptions.forceRename = ['true'];
            }
            if (options.tags) {
                queryOptions.tags = options.tags;
                if (options.requireAllTags) {
                    queryOptions.allTags = ['true'];
                }
            }
            if (options.limit) {
                queryOptions.limit = [options.limit.toString()];
            }
            queryItems.push(...Object.keys(queryOptions).map((key) => {
                const value = queryOptions[key];
                return `${key}=${value.map(encodeURIComponent).join(',')}`;
            }));
        }
        if (additionalQuery) {
            queryItems.push(additionalQuery);
        }
        const queryString = queryItems.join('&');
        return queryString;
    }
    /**
     * Makes an HTTP request using Axios, while tracing request and response details.
     */
    async request(method, uri, data, config, allowNotFound) {
        this.trace(`${method} ${uri}`);
        this.traceHeaders(config.headers);
        this.traceContent(data);
        const traceResponse = (response) => {
            this.trace(`${response.status} ${response.statusText}`);
            this.traceHeaders(response.headers);
            this.traceContent(response.data);
        };
        try {
            config.url = uri;
            config.method = method;
            config.data = data;
            const response = await axios_1.default.request(config);
            traceResponse(response);
            // This assumes that TResult is always boolean for DELETE requests.
            return (method === 'DELETE' ? true : response.data);
        }
        catch (e) {
            if (!(e instanceof Error) || !e.isAxiosError)
                throw e;
            const requestError = e;
            if (requestError.response) {
                traceResponse(requestError.response);
                if (allowNotFound && requestError.response.status === 404) {
                    return (method === 'DELETE' ? false : null);
                }
            }
            requestError.message = this.getResponseErrorMessage(requestError);
            // Axios errors have too much redundant detail! Delete some of it.
            delete requestError.request;
            if (requestError.response) {
                delete requestError.config.httpAgent;
                delete requestError.config.httpsAgent;
                delete requestError.response.request;
            }
            throw requestError;
        }
    }
    traceHeaders(headers) {
        for (const [headerName, headerValue] of Object.entries(headers)) {
            if (headerName === 'Authorization') {
                this.traceAuthorizationHeader(headerName, headerValue);
                return;
            }
            this.trace(`${headerName}: ${headerValue !== null && headerValue !== void 0 ? headerValue : ''}`);
        }
    }
    traceAuthorizationHeader(key, value) {
        if (typeof value !== 'string')
            return;
        const spaceIndex = value.indexOf(' ');
        if (spaceIndex < 0) {
            this.trace(`${key}: [${value.length}]`);
            return;
        }
        const scheme = value.substring(0, spaceIndex);
        const token = value.substring(spaceIndex + 1);
        if (scheme.toLowerCase() === tunnelManagementClient_1.TunnelAuthenticationSchemes.tunnel.toLowerCase()) {
            const tokenProperties = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.tryParse(token);
            if (tokenProperties) {
                this.trace(`${key}: ${scheme} <${tokenProperties}>`);
                return;
            }
        }
        this.trace(`${key}: ${scheme} <token>`);
    }
    traceContent(data) {
        if (typeof data === 'object') {
            data = JSON.stringify(data, undefined, '  ');
        }
        if (typeof data === 'string') {
            this.trace(TunnelManagementHttpClient.replaceTokensInContent(data));
        }
    }
    static replaceTokensInContent(content) {
        var _a;
        const tokenRegex = /"(eyJ[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+)"/;
        let match = tokenRegex.exec(content);
        while (match) {
            let token = match[1];
            const tokenProperties = tunnelAccessTokenProperties_1.TunnelAccessTokenProperties.tryParse(token);
            token = (_a = tokenProperties === null || tokenProperties === void 0 ? void 0 : tokenProperties.toString()) !== null && _a !== void 0 ? _a : 'token';
            content =
                content.substring(0, match.index + 1) +
                    '<' +
                    token +
                    '>' +
                    content.substring(match.index + match[0].length - 1);
            match = tokenRegex.exec(content);
        }
        return content;
    }
}
exports.TunnelManagementHttpClient = TunnelManagementHttpClient;
//# sourceMappingURL=tunnelManagementHttpClient.js.map